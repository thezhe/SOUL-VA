/** GNU GPLv3 License

    Copyright (C) 2021 ZheDeng
    TheZheDeng@gmail.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

/** SOUL-VA (https://github.com/thezhe/SOUL-VA)

    Effects are 'Processors' under 'VA::HighLevel'

    The interface is nearly identical to soul::filters EXCEPT:
        - Each effect has at least input and output SampleType streams named 'in' and 'out'
        - All input events are of type 'float'
        - Max gain applied via an effect (excluding Makeup) is set to 1.5 or about +3.52 dB. 
        In practice (depending on sampling rate), signals may be boosted up to approximately +6 dB.
        - No user-defined types:
            *'SampleType' is float64<2>
            *The internal 'CoeffType' is float64<2>
            *Coefficient 'updateInterval' is every 256 samples at 44.1kHz 
            or every 278 samples at 48 kHz (linearly scaled with sample rate)
        - Parameters not suitable for modulation are commented as 'UNSMOOTHED' in their annotations. 
        Annotations with "boolean" and "text" values are assumed to be unsuitable for modulation.
        - Expanded set of vector-friendly functions (see 'Vectorized Intrinsic/Helper' sections)
        - Algebraic operations are preferred to avoid expensive transcendentals while providing superior
        accuracy and click-free modulation when compared to lookup tables
        See: https://en.wikipedia.org/wiki/Algebraic_function
        - Common sampling rates from 44.1 to 192 kHz are supported, but the internal sampling rate will always be either 
        44.1 or 48 kHz. This allows for consistent rendering and antialiasing of all effects, including ones that behave 
        differently depending on sample rate.
        - Each section is marked with a date of last stable update (MM/DD/YYYY)
*/

/** Next version (1.1.0) changelog
    - New Effects: TheExpressor, TheSplit, TheUtility, TheSlewEQ
    - Tests now use Octave via PLUG-QA and support multichannel IO
    - More parameters are now smoothed and modulation stable
    - Effects can now run at common sample rates from 44.1 to 192 kHz
*/

/** Task List

    - generic ADAA snippet and implementation
    - smoothed parameter compile time
    - improved smoothing: log smoothing
    - TheSlewEQ
    - TheChorus, TheBass, TheSplit update to 192kHz support and TheExpressor standard

    - TheChorus LadderLpfS input is Omega
    - low attack times the split, and compensate attack * 2 for attacks & sustains
    - more Processors, include integrator processors, more modularity and oversampling/ADAA granularity
    - TheBass boilerplate, abs before stereo link and rectified lan
    - small dx approximation for hysteretic L  
*/

namespace VA 
{
/*==============================================================================
VA::HighLevel Processors                                                03/10/22
==============================================================================*/

    /** High-level Processors made of components from 'VA' and 'soul' namespaces 
    
        ALL effects can behave nonlinearly and add their own 'virtual analog warmth' 
    */
    namespace HighLevel
    {          
        /** Onepole-Style EQ using Slew Limiting
        
            Use case: Nonlinear EQ
        */
        namespace TheSlewEQ
        {            
            graph Processor(float iSlewMax_dB = 0,
                            int iModeIdx = OnepoleMixer::ModeIdx::LP,
                            float iGain_dB = 0,
                            float iMakeup_dB = 0,
                            float iMixPercent = 100)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    event float slewMaxIn;
                    event float modeIn [[ name: "Mode", min: 0, init: iModeIdx, text: "LP|HP|AP|LS|HS" ]];
                    event float gainIn [[ name: "Gain", min: -24, max: 24, init: iGain_dB, unit: "dB", step: 0.1f ]];

                    smoothedVolume.volumeIn makeupIn;
                    smoothedMixPan.mixIn;
                }
        
                let
                {
                    internalDS0 = Internal::Processor (iSlewMax_dB, iModeIdx, iGain_dB);
                    internalDS2 = Internal::Processor (iSlewMax_dB, iModeIdx, iGain_dB) / 2;
                    internalDS4 = Internal::Processor (iSlewMax_dB, iModeIdx, iGain_dB) / 4;
                    mux3To1Fs = Mux3To1Fs::Processor;

                    smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, 0);
                    smoothedVolume = SmoothedVolume::Processor (iMakeup_dB);
                }
        
                connection
                {
                    //shared input events
                    slewMaxIn -> internalDS0.slewMaxIn, internalDS2.slewMaxIn, internalDS4.slewMaxIn;
                    modeIn -> internalDS0.modeIn, internalDS2.modeIn, internalDS4.modeIn;
                    gainIn -> internalDS0.gainIn, internalDS2.gainIn, internalDS4.gainIn;               

                    //dynamically downsample to 44.1/48 kHz
                    [sinc] in -> internalDS0.in, internalDS2.in, internalDS4.in;
        
                    [sinc] internalDS0.out -> mux3To1Fs.in;
                    [sinc] internalDS2.out -> mux3To1Fs.in1;
                    [sinc] internalDS4.out -> mux3To1Fs.in2;
        
                    in -> smoothedMixPan.dryIn;

                    mux3To1Fs.out -> smoothedVolume.in;
                    smoothedVolume.out -> smoothedMixPan.wetIn;
                    smoothedMixPan.out -> out;
                }
            }
            
            namespace Internal
            {
                graph Processor(float iSlewMax_dB = 0,
                                int iModeIdx = OnepoleMixer::ModeIdx::LP,
                                float iGain_dB = 0)
                {
                    input stream SampleType in;
                    output stream SampleType out;
        
                    input
                    {
                        onepoleSlew.slewMaxIn;
                        onepoleMixer.modeIn [[ name: "Mode", min: OnepoleMixer::ModeIdx::LP, init: iModeIdx, text: "LP|HP|AP|LS|HS" ]];
                        onepoleMixer.gainIn [[ name: "Gain", min: -24, max: 24, init: iGain_dB, unit: "dB", step: 0.1f ]];
                    }
        
                    let
                    {
                        dcBlocker = DC_Blocker::Processor;

                        onepoleSlew = OnepoleSlew::Processor (iSlewMax_dB);
                        onepoleMixer = OnepoleMixer::Processor (iModeIdx, iGain_dB);
                    }
        
                    connection
                    {
                        in -> dcBlocker -> onepoleSlew.in;

                        onepoleSlew.lowpassOut -> onepoleMixer.lowpassIn;
                        onepoleSlew.highpassOut -> onepoleMixer.highpassIn;
                        onepoleMixer.out -> out;
                    }
                }
            }
        }   

        /** Utility Processor
        
            Use case: Mix, Pan, Makeup, and Complement

            Notes: 
            - This is a common Processor and may be used in other Processors in this namespace
            - Use directly; DO NOT over/undersample or add additional filtering.
        */
        namespace TheUtility
        {                   
            namespace PanModeIdx
            {
                let Unlinked = 0;
                let Linked = 1;
                let Inverted = 2;
                let NumIdxs = 3;
            }

            graph Processor(bool iWetComplementBool = false,
                            bool iInvertWetL_Bool = false,
                            bool iInvertWetR_Bool = false,
                            float iMakeup_dB = 0,
                            float iMixPercent = 100,
                            float iPanDry = 0,
                            float iPanWet = 0,
                            int iPanModeIdx = PanModeIdx::Unlinked)
            {
                input stream SampleType in, dryIn;
                output stream SampleType out;
    
                input
                {
                    mux2To1.idxIn complementIn [[ name: "Complement", init: float (iWetComplementBool), boolean, group: "Wet" ]];                   
                    phaseInverts.invertL_In [[ name: "Invert L", init: float (iInvertWetL_Bool), boolean, group: "Wet" ]];
                    phaseInverts.invertR_In [[ name: "Invert R", init: float (iInvertWetR_Bool), boolean, group: "Wet" ]];

                    smoothedMakeupMixPans.makeupIn [[ name: "Makeup", min: -24, max: 24, init: iMakeup_dB, step: 0.1f, unit: "dB", group: "Volume" ]];
                    smoothedMakeupMixPans.mixIn [[ name: "Mix", min: 0, max: 100, init: iMixPercent, unit: "%", step: 1, group: "Volume" ]];

                    smoothedMakeupMixPans.panDryIn [[ name: "Dry", min: -1, max: 1, init: iPanDry, step: 0.01f, group: "Pan" ]];
                    smoothedMakeupMixPans.panWetIn [[ name: "Wet", min: -1, max: 1, init: iPanWet, step: 0.01f, group: "Pan" ]];
                    event float panModeIn [[ name: "Mode", min: 0, init: iPanModeIdx, text: "Unlinked|Linked|Inverted", group: "Pan" ]]; //this doesn't do anything
                }
    
                let
                {
                    mux2To1 = Mux2To1::Processor (iWetComplementBool);
                    difference = Difference::Processor;

                    phaseInverts = PhaseInverts::Processor (iInvertWetL_Bool, false);

                    smoothedMakeupMixPans = SmoothedMakeupMixPans::Processor (iMakeup_dB, iMixPercent, iPanDry, iPanWet);
                }
    
                connection
                {
                    dryIn -> difference.in, smoothedMakeupMixPans.in;
                    in -> difference.in1, mux2To1.in;
                    difference.out -> mux2To1.in1;

                    mux2To1.out -> phaseInverts.in;
                    phaseInverts.out -> smoothedMakeupMixPans.wetIn;

                    smoothedMakeupMixPans.out -> out;
                }
            }
        }

        /** Signal splitter
    
            Use case: Center/Sides (spatial), Crossover (frequency), Loud/Soft (amplitude), Attack/Sustain (time)
        */
        namespace TheSplit
        {            
            namespace Modes
            {
                let CenterSides = 0;
                let LowHigh = 1;
                let AttackSustain = 2;
                let LoudSoft = 3;
                let NumModes = 4;
            }

            graph Processor(int iMode = Modes::CenterSides,
                            bool iSwapOutputsBool = false,
                            float iCenterSidesPercent = 100,
                            float iFrequencyHz = 1000,
                            float iAttackMs = 4,
                            float iSustainMs = 30,
                            float iSensitivity_dB = 36,
                            float iThreshold_dB = -30,
                            float iReleaseMs = 30,
                            float iStereoLinkLsPercent = 0)
            {
                input stream SampleType in;
                output stream SampleType out, out1;
        
                input event 
                {
                    float modeIn [[ name: "Mode", min: 0, init: iMode, text: "C&S|L&H|A&S|L&S", group: "Main" /*UNSMOOTHED*/ ]];
                    float swapIn [[ name: "Output Swap", init: float (iSwapOutputsBool), boolean, group: "Main" /*UNSMOOTHED*/ ]];

                    float centerSidesIn [[ name: "Split Amount", min: 0, max: 100, init: iCenterSidesPercent, unit: "%", step: 1, group: "Centers & Sides" ]];

                    float frequencyIn [[ name: "Frequency", min: 20, max: 20000, init: iFrequencyHz, step: 1, unit: "Hz", group: "Lows & Highs" ]];

                    float attackIn [[ name: "Attack", min: 4, max: 26, init: iAttackMs, step: 1, unit: "ms", group: "Attacks & Sustains" ]];
                    float sustainIn [[ name: "Sustain", min: 30, max: 200, init: iSustainMs, step: 1, unit: "ms", group: "Attacks & Sustains" ]];
                    float sensitivityIn [[ name: "Sensitivity", min: 0, max: 36, init: iSensitivity_dB, step: 1, unit: "dB", group: "Attacks & Sustains" ]];

                    float thresholdIn [[ name: "Threshold", min: -50, max: 0, init: iThreshold_dB, unit: "dB", step: 1, group: "Louds & Softs" ]];
                    float releaseIn [[ name: "Release", min: 30, max: 999, init: iReleaseMs, unit: "ms", step: 1, group: "Louds & Softs" ]];
                    float stereoLinkLsIn [[ name: "Stereo Link", min: 0, max: 100, init: iStereoLinkLsPercent, unit: "%", step: 1, group: "Louds & Softs" ]];
                }
        
                let
                {
                    internalDS0 = Internal::Processor (iMode, iSwapOutputsBool, iCenterSidesPercent, iFrequencyHz, iAttackMs, iSustainMs, iSensitivity_dB, iThreshold_dB, iReleaseMs, iStereoLinkLsPercent);
                    internalDS2 = Internal::Processor (iMode, iSwapOutputsBool, iCenterSidesPercent, iFrequencyHz, iAttackMs, iSustainMs, iSensitivity_dB, iThreshold_dB, iReleaseMs, iStereoLinkLsPercent) / 2;
                    internalDS4 = Internal::Processor (iMode, iSwapOutputsBool, iCenterSidesPercent, iFrequencyHz, iAttackMs, iSustainMs, iSensitivity_dB, iThreshold_dB, iReleaseMs, iStereoLinkLsPercent) / 4;
                    mux3To1Fs = Mux3To1Fs::Processor;
                    mux3To1Fs1 = Mux3To1Fs::Processor;
                }
        
                connection
                {
                    //shared input events
                    modeIn -> internalDS0.modeIn, internalDS2.modeIn, internalDS4.modeIn;
                    swapIn -> internalDS0.swapIn, internalDS2.swapIn, internalDS4.swapIn;  
                    frequencyIn -> internalDS0.frequencyIn, internalDS2.frequencyIn, internalDS4.frequencyIn;
                    attackIn -> internalDS0.attackIn, internalDS2.attackIn, internalDS4.attackIn;
                    releaseIn -> internalDS0.releaseIn, internalDS2.releaseIn, internalDS4.releaseIn;
                    sensitivityIn -> internalDS0.sensitivityIn, internalDS2.sensitivityIn, internalDS4.sensitivityIn;
                    thresholdIn -> internalDS0.thresholdIn, internalDS2.thresholdIn, internalDS4.thresholdIn;
                    releaseIn -> internalDS0.releaseIn, internalDS2.releaseIn, internalDS4.releaseIn;
                    stereoLinkLsIn -> internalDS0.stereoLinkLsIn, internalDS2.stereoLinkLsIn, internalDS4.stereoLinkLsIn;

                    //dynamically downsample to 44.1/48 kHz
                    [sinc] in -> internalDS0.in, internalDS2.in, internalDS4.in;
        
                    [sinc] internalDS0.out -> mux3To1Fs.in;
                    [sinc] internalDS2.out -> mux3To1Fs.in1;
                    [sinc] internalDS4.out -> mux3To1Fs.in2;

                    [sinc] internalDS0.out1 -> mux3To1Fs1.in;
                    [sinc] internalDS2.out1 -> mux3To1Fs1.in1;
                    [sinc] internalDS4.out1 -> mux3To1Fs1.in2;
        
                    mux3To1Fs.out -> out;
                    mux3To1Fs1.out -> out1;
                }
            }
            
            namespace Internal
            {
                graph Processor(int iMode,
                                bool iSwapOutputsBool,
                                float iCenterSidesPercent,
                                float iFrequencyHz,
                                float iAttackMs,
                                float iSustainMs,
                                float iSensitivity_dB,
                                float iThreshold_dB,
                                float iReleaseMs,
                                float iStereoLinkLsPercent)
                {
                    input stream SampleType in;
                    output stream SampleType out, out1;
            
                    input
                    {
                        event float modeIn;
                        event float swapIn;

                        splitCenterSides.centerSidesIn;

                        pCrossover.frequencyIn;

                        splitAttackSustain.attackIn;
                        splitAttackSustain.sustainIn;
                        splitAttackSustain.sensitivityIn;

                        splitLoudSoft.thresholdIn;
                        splitLoudSoft.releaseIn;
                        splitLoudSoft.stereoLinkIn stereoLinkLsIn;
                    }
            
                    let
                    {
                        //non-boilerplate Processors
                        splitCenterSides = SplitCenterSides::Processor (iCenterSidesPercent);
                        pCrossover = filt::tpt::crossover::Processor (iFrequencyHz);
                        splitAttackSustain = SplitAttackSustain::Processor (iAttackMs, iSustainMs, iSensitivity_dB, 100);
                        splitLoudSoft = SplitLoudSoft::Processor (iThreshold_dB, iReleaseMs, iStereoLinkLsPercent);
                        
                        mux4To1_0 = Mux4To1::Processor (iMode);
                        mux4To1_1 = Mux4To1::Processor (iMode);

                        mux2To1_0 = Mux2To1::Processor (iSwapOutputsBool);
                        mux2To1_1 = Mux2To1::Processor (iSwapOutputsBool);

                        //boilerplate Processors
                        dcBlockerIn = DC_Blocker::Processor;
                        dcBlockerOut = DC_Blocker::Processor;
                        dcBlockerOut1 = DC_Blocker::Processor;
                    }
            
                    connection
                    {
                        modeIn -> mux4To1_0.idxIn, mux4To1_1.idxIn;
                        swapIn -> mux2To1_0.idxIn, mux2To1_1.idxIn;

                        in -> dcBlockerIn -> splitCenterSides.in, pCrossover.in, splitLoudSoft.in, splitAttackSustain.in;

                        splitCenterSides.centerOut -> mux4To1_0.in;
                        splitCenterSides.sidesOut -> mux4To1_1.in;

                        pCrossover.lowOut -> mux4To1_0.in1;
                        pCrossover.highOut -> mux4To1_1.in1;
                        
                        splitAttackSustain.attackOut -> mux4To1_0.in2;
                        splitAttackSustain.sustainOut -> mux4To1_1.in2;

                        splitLoudSoft.loudOut -> mux4To1_0.in3;
                        splitLoudSoft.softOut -> mux4To1_1.in3;

                        mux4To1_0.out -> mux2To1_0.in, mux2To1_1.in1;
                        mux4To1_1.out -> mux2To1_0.in1, mux2To1_1.in;

                        mux2To1_0.out -> dcBlockerOut -> out;
                        mux2To1_1.out -> dcBlockerOut1 -> out1;
                    }
                }
            }
        }

        /** Upwards/Downwards (Ex)pander/Com(pressor) with a colored knee

            Notes:
            - Use case: limiter, general dynamics processor, parallel/ny compression, sidechain, emphasis/de-emphasis
            - Tail: 0.5 s
        */
        namespace TheExpressor
        {            
            graph Processor(bool iSidechainBool = false,
                            float iAttackMs = 0.5f,
                            float iReleaseMs = 30, 
                            float iStereoLinkPercent = 0,
                            float iThreshold_dB = -50,
                            float iRatio0 = 20,
                            float iRatio1 = 1,
                            float iSoftness_dB = 0,
                            float iColor_dB = 0,
                            float iHpfCutoffHz = 1,
                            float iLpfCutoffHz = 20000,
                            float iMakeup_dB = 0,
                            float iMixPercent = 100)
            {
                input stream SampleType in, scIn;
                output stream SampleType out, guiOut;
        
                input
                {
                    event float attackIn [[ name: "Attack", min: 0.5f, max: 50, init: iAttackMs, unit: "ms", step: 0.1, group: "Main"]];
                    event float releaseIn [[ name: "Release", min: 30, max: 3000, init: iReleaseMs, unit: "ms", step: 1, group: "Main" ]];
                    event float thresholdIn [[ name: "Threshold", min: -50.f, max: 0.f, init: iThreshold_dB, unit: "dB", step: 0.1f, group: "Main" ]];

                    event float ratio0In [[ name: "Post-Threshold", min: 0.5f, max: 20.f, init: iRatio0, step: 0.1f, group: "Ratios" ]];
                    event float ratio1In [[ name: "Pre-Threshold", min: 0.5f, max: 1.5f, init: iRatio1, step: 0.1f, group: "Ratios" ]];

                    event float sidechainIn [[ name: "Sidechain", init: float (iSidechainBool), boolean, group: "Detector" /*UNSMOOTHED*/ ]];   
                    event float cutoffHP_In [[ name: "High Pass", min: 1, max: 500, init: iHpfCutoffHz, unit: "Hz", step: 1, group: "Detector"]];
                    event float cutoffLP_In [[ name: "Low Pass", min: 500, max: 20000, init: iLpfCutoffHz, unit: "Hz", step: 1, group: "Detector"]];
                    event float stereoLinkIn [[ name: "Stereo Link", min: 0, max: 100, init: iStereoLinkPercent, unit: "%", step: 1, group: "Detector" ]];

                    event float softnessIn [[ name: "Softness", min: 0, max: 24, init: iSoftness_dB, unit: "dB", step: 0.1f, group: "Knee" ]];
                    event float colorIn [[ name: "Color", min: -24, max: 24, init: iColor_dB, unit: "dB", step: 0.1f, group: "Knee" ]]; 
                                  
                    smoothedVolume.volumeIn makeupIn [[ name: "Makeup", min: -6, max: 50, init: iMakeup_dB, step: 0.1f, unit: "dB", group: "Utility" ]];
                    smoothedMixPan.mixIn [[ name: "Mix", min: 0, max: 100, init: iMixPercent, unit: "%", step: 1, group: "Utility" ]];
                }
        
                let
                {
                    internalDS0 = Internal::Processor (iSidechainBool, iAttackMs, iReleaseMs, iStereoLinkPercent, iThreshold_dB, iRatio0, iRatio1, iSoftness_dB, iColor_dB, iHpfCutoffHz, iLpfCutoffHz);
                    internalDS2 = Internal::Processor (iSidechainBool, iAttackMs, iReleaseMs, iStereoLinkPercent, iThreshold_dB, iRatio0, iRatio1, iSoftness_dB, iColor_dB, iHpfCutoffHz, iLpfCutoffHz) / 2;
                    internalDS4 = Internal::Processor (iSidechainBool, iAttackMs, iReleaseMs, iStereoLinkPercent, iThreshold_dB, iRatio0, iRatio1, iSoftness_dB, iColor_dB, iHpfCutoffHz, iLpfCutoffHz) / 4;
                    mux3To1Fs = Mux3To1Fs::Processor;
                    mux3To1Fs1 = Mux3To1Fs::Processor;

                    smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, 0);
                    smoothedVolume = SmoothedVolume::Processor (iMakeup_dB);
                }
        
                connection
                {
                    //input event float
                    attackIn -> internalDS0.attackIn, internalDS2.attackIn, internalDS4.attackIn;   
                    releaseIn -> internalDS0.releaseIn, internalDS2.releaseIn, internalDS4.releaseIn;
                    thresholdIn -> internalDS0.thresholdIn, internalDS2.thresholdIn, internalDS4.thresholdIn;
                    
                    ratio0In -> internalDS0.ratio0In, internalDS2.ratio0In, internalDS4.ratio0In;
                    ratio1In -> internalDS0.ratio1In, internalDS2.ratio1In, internalDS4.ratio1In;

                    sidechainIn -> internalDS0.sidechainIn, internalDS2.sidechainIn, internalDS4.sidechainIn;
                    cutoffHP_In -> internalDS0.cutoffHP_In, internalDS2.cutoffHP_In, internalDS4.cutoffHP_In;
                    cutoffLP_In -> internalDS0.cutoffLP_In, internalDS2.cutoffLP_In, internalDS4.cutoffLP_In;
                    stereoLinkIn -> internalDS0.stereoLinkIn, internalDS2.stereoLinkIn, internalDS4.stereoLinkIn;

                    softnessIn -> internalDS0.softnessIn, internalDS2.softnessIn, internalDS4.softnessIn;
                    colorIn -> internalDS0.colorIn, internalDS2.colorIn, internalDS4.colorIn;
                    
                    //apply 3 downsampling rates
                    [sinc] in -> internalDS0.in, internalDS2.in, internalDS4.in;
                    [sinc] scIn -> internalDS0.scIn, internalDS2.scIn, internalDS4.scIn; 

                    [sinc] internalDS0.out -> mux3To1Fs.in;
                    [sinc] internalDS2.out -> mux3To1Fs.in1;
                    [sinc] internalDS4.out -> mux3To1Fs.in2;

                    [sinc] internalDS0.guiOut -> mux3To1Fs1.in;
                    [sinc] internalDS2.guiOut -> mux3To1Fs1.in1;
                    [sinc] internalDS4.guiOut -> mux3To1Fs1.in2;

                    mux3To1Fs1.out -> guiOut;

                    //utility
                    in -> smoothedMixPan.dryIn;
                    mux3To1Fs.out -> smoothedVolume.in;
                    smoothedVolume.out -> smoothedMixPan.wetIn;
                    smoothedMixPan.out -> out;
                }
            }
            
            namespace Internal
            {
                graph Processor(bool iSidechainBool,
                                float iAttackMs,
                                float iReleaseMs, 
                                float iStereoLinkPercent,
                                float iThreshold_dB,
                                float iRatio0,
                                float iRatio1,
                                float iSoftness_dB,
                                float iColor_dB,
                                float iHpfCutoffHz,
                                float iLpfCutoffHz)
                {
                    input stream SampleType in, scIn;
                    output stream SampleType out, guiOut;

                    input
                    {
                        mux2To1.idxIn sidechainIn;   

                        ballisticsFilter.attackIn;
                        ballisticsFilter.releaseIn;

                        stereoLink.stereoLinkIn;

                        ctfColor.thresholdIn;
                        ctfColor.ratio0In;
                        ctfColor.ratio1In;
                        ctfColor.softnessIn;
                        ctfColor.colorIn;

                        pSvf.frequencyIn cutoffHP_In;
                        pSvf1.frequencyIn cutoffLP_In;
                    }

                    let
                    {
                        dcBlocker = DC_Blocker::Processor;
                        ultraBlocker = UltraBlocker::Processor;

                        mux2To1 = Mux2To1::Processor (iSidechainBool);
                        
                        pSvf = filt::tpt::svf::Processor (iHpfCutoffHz, FLOAT_DIV_SQRT_TWO);
                        pSvf1 = filt::tpt::svf::Processor (iLpfCutoffHz, FLOAT_DIV_SQRT_TWO);

                        absADAA = AbsADAA::Processor;     

                        ballisticsFilter = BallisticsFilter::Processor (iAttackMs, iReleaseMs);
                        stereoLink = StereoLink::Processor (iStereoLinkPercent);
                        ctfColor = CTF_Color::Processor (iThreshold_dB, iRatio0, iRatio1, iSoftness_dB, iColor_dB);

                        applyGain = ApplyGain::Processor;
                    }

                    connection
                    {
                        in -> dcBlocker -> ultraBlocker -> applyGain.in;

                        in -> mux2To1.in;
                        scIn -> mux2To1.in1;
                        mux2To1.out -> pSvf.in; 
                        pSvf.highpassOut -> pSvf1.in;
                        pSvf1.lowpassOut -> absADAA -> stereoLink.in;
                        stereoLink.out -> ballisticsFilter.in;
                        ballisticsFilter.out -> ctfColor.in;
                        ctfColor.out -> applyGain.b, guiOut;

                        applyGain.out -> out;                    
                    }
                }
            }
        }

        /** Modulated 'DelayLine' with 'LadderLpfS' attached to its output
        
            Notes:
            - Use case: chorus, slow flange, doubler, stereo widener
            - Loosely based on Boss CE-3 Chorus Pedal
            - Tail: 0.5 s
        */
        namespace TheChorus
        {            
            graph Processor(float iDepthPercent = 0,
                            float iRateHz = 0,
                            float iWidthDeg = 0,
                            int iMode = Lfo::Modes::Triangle,
                            float iDelayMs = 0,
                            float iCutoffHz = 3000,
                            float iMakeup_dB = 0,
                            float iMixPercent = 100,
                            float iPan = 0)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input 
                {
                    event float depthIn [[ name: "Depth", min: 0, max: 100, init: iDepthPercent, unit: "%", step: 1, group: "Main" ]];
                    event float rateIn [[ name: "Rate", min: 0.1, max: 4.0, init: iRateHz, unit: "Hz", step: 0.1, group: "Main" ]];
                    event float widthIn [[ name: "Width", min: -180, max: 180, init: iWidthDeg, unit: "deg", step: 1, group: "Main" /*UNSMOOTHED*/ ]];
                    
                    event float modeIn [[ name: "Waveform", init: iMode, boolean, text: "Tri|Sine", group: "LFO" /*UNSMOOTHED*/ ]];
                    event float delayIn [[ name: "Min Delay", min: 0, max: 35, init: iDelayMs, unit: "ms", step: 1, group: "LFO" /*UNSMOOTHED*/ ]];
                    event float cutoffIn [[ name: "Cutoff", min: 3000, max: 18000, init: iCutoffHz, unit: "Hz", step: 1, group: "BBD Ladder" ]];

                    smoothedVolume.volumeIn makeupIn [[ name: "Makeup", min: -12, max: 12, init: iMakeup_dB, step: 0.1f, unit: "dB", group: "Utility" ]];
                    smoothedMixPan.mixIn [[ name: "Mix", min: 0, max: 100, init: iMixPercent, unit: "%", step: 1, group: "Utility" ]];
                    smoothedMixPan.panIn [[ name: "Pan", min: -1, max: 1, init: iPan, step: 0.01f, group: "Utility" ]];
                }
        
                let
                {
                    internalDS0 = Internal::Processor (iDepthPercent, iRateHz, iWidthDeg, iMode, iDelayMs, iCutoffHz);
                    internalDS2 = Internal::Processor (iDepthPercent, iRateHz, iWidthDeg, iMode, iDelayMs, iCutoffHz) / 2;
                    internalDS4 = Internal::Processor (iDepthPercent, iRateHz, iWidthDeg, iMode, iDelayMs, iCutoffHz) / 4;
                    mux3To1Fs = Mux3To1Fs::Processor;
                
                    smoothedVolume = SmoothedVolume::Processor (iMakeup_dB);
                    smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, iPan);
                }
        
                connection
                {
                    //shared input events
                    depthIn -> internalDS0.depthIn, internalDS2.depthIn, internalDS4.depthIn;
                    rateIn -> internalDS0.rateIn, internalDS2.rateIn, internalDS4.rateIn;
                    widthIn -> internalDS0.widthIn, internalDS2.widthIn, internalDS4.widthIn;
                    modeIn -> internalDS0.modeIn, internalDS2.modeIn, internalDS4.modeIn;
                    delayIn -> internalDS0.delayIn, internalDS2.delayIn, internalDS4.delayIn;
                    cutoffIn -> internalDS0.cutoffIn, internalDS2.cutoffIn, internalDS4.cutoffIn;
        
                    //dynamically downsample to 44.1/48 kHz
                    [sinc] in -> internalDS0.in, internalDS2.in, internalDS4.in;
        
                    [sinc] internalDS0.out -> mux3To1Fs.in;
                    [sinc] internalDS2.out -> mux3To1Fs.in1;
                    [sinc] internalDS4.out -> mux3To1Fs.in2;
        
                    //utility
                    in -> smoothedMixPan.dryIn;
                    mux3To1Fs.out -> smoothedVolume.in;
                    smoothedVolume.out -> smoothedMixPan.wetIn;
                    smoothedMixPan.out -> out;
                }
            }
            
            namespace Internal
            {
                graph Processor (float iDepthPercent,
                                float iRateHz,
                                float iWidthDeg,
                                int iMode,
                                float iDelayMs,
                                float iCutoffHz)
                {
                    input stream SampleType in;
                    output stream SampleType out;
            
                    input
                    { 
                        lfo.depthIn;
                        lfo.rateIn;
                        lfo.widthIn;

                        lfo.modeIn; 
                        delayLine.delayIn;
                        ladderLpfS.cutoffIn;
                    }
            
                    let
                    {
                        dcBlocker = DC_Blocker::Processor;

                        lfo = Lfo::Processor (iDepthPercent, iRateHz, iWidthDeg, iMode);

                        delayLine = DelayLine::Processor (iDelayMs, 35, 4);
                        ladderLpfS = LadderLpfS::Processor (iCutoffHz, 1, 0.5f);
                    }
            
                    connection
                    {
                        lfo.out -> delayLine.lfoIn;
                        
                        in -> dcBlocker -> delayLine.in;
                        delayLine.out -> ladderLpfS.in;
                        ladderLpfS.out -> out;
                    }
                }
            }
        }

        /** 'OnepoleC' in all pass mode modulated by 'LanADAA' 

            Use case: boost and sustain low frequencies
        */
        namespace TheBass
        {
            graph Processor (float iNonlinearity = 250, float iStereoLinkPercent = 100)
            {
                input stream SampleType in;
                output stream SampleType out;
        
                input
                {
                    event float nonlinearityIn [[ name: "Nonlin", min: 0, max: 350, init: iNonlinearity, step: 1 /*UNSMOOTHED*/]];
                    stereoLink.stereoLinkIn;
                    autoSmoothedVolume.parameterIn volumeIn;
                    //smoothedMixPan.mixIn;
                    //smoothedMixPan.panIn;
                }
        
                let
                {
                    stereoLink = StereoLink::Processor (iStereoLinkPercent);

                    internal = Internal::Processor (iNonlinearity) * 2;
                    onepoleMixer = OnepoleMixer::Processor (OnepoleMixer::ModeIdx::AP, 0);

                    //boilerplate Processors
                    dcBlockerIn = filt::dc_blocker::Processor (0.1);
                    autoSmoothedVolume = AutoSmoothedVolume::Processor (AutoParameter::Modes::Volume_OnepoleC_Lan);
                   // smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, iPan);
                }
        
                connection
                {
                    nonlinearityIn -> internal.nonlinearityIn;
                    nonlinearityIn -> autoSmoothedVolume.controlIn;

                    in -> dcBlockerIn -> stereoLink.in, internal.in;

                    stereoLink.out -> internal.Lin;

                    internal.highpassOut -> onepoleMixer.highpassIn;
                    internal.lowpassOut -> onepoleMixer.lowpassIn;
                    
                    onepoleMixer.out -> autoSmoothedVolume.in;
                    autoSmoothedVolume.out -> out; 
                }
            }

            namespace Internal 
            {
                graph Processor (float iNonlinearity)
                {
                    input stream SampleType in, Lin;
                    output stream SampleType highpassOut, lowpassOut;
            
                    input
                    {
                        L.nonlinearityIn;
                    }

                    let
                    {
                        L = LanADAA::Processor (iNonlinearity);
                        onepoleC = OnepoleC::Processor;
                    }
            
                    connection
                    {
                        in -> onepoleC.in;

                        Lin -> L.in;
                        L.Omega -> onepoleC.Omega;

                        onepoleC.highpassOut -> highpassOut;
                        onepoleC.lowpassOut -> lowpassOut;
                    }
                }
            }    
        }

        /** A dummy processor that doesn't modify streams
        
            Use case: debugging
        */
        namespace TheDummy
        {
            graph Processor()
            {
                input stream SampleType in;
                output stream SampleType out;
                
                connection
                {
                    in -> out;
                }
            }
        }
    } //namespace HighLevel

/*==============================================================================
Filter Processors                                                       02/24/22
==============================================================================*/

    /** Ladder Low Pass Filter with variable order and saturating state 
    
        Notes:
        - currently hard-coded to 4th order lpf
        - Resonance up to 2 reccomended
        - Even though its nonlinear, the filter can become unstable if using an unbounded nonlinearity
          i.e., the filter can self-oscillate with nonlinear functions like 'tanh'
    */
    namespace LadderLpfS
    {       
        graph Processor (float iCutoff, float iResonance, float iNonlinearity)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                smoothedParameter0.in cutoffIn [[ name: "Cutoff", min: 3000, max: 18000, init: iCutoff, unit: "Hz", step: 1 ]];
                smoothedParameter1.in resonanceIn [[ name: "Resonance", min: 0, max: 2, init: iResonance, step: 0.01f ]];
                internal.nonlinearityIn;
            }
    
            let
            {
                smoothedParameter0 = UnsmoothedParameter::Processor (UnsmoothedParameter::ParameterType (iCutoff), UnsmoothedParameter::ModeIdx::Identity);
                smoothedParameter1 = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iResonance), SmoothedParameter::ModeIdx::GainToGain);
                
                internal = Internal::Processor (iNonlinearity) * 2;
            }
    
            connection
            {
                smoothedParameter0.out -> internal.G_OnepoleIn;
                smoothedParameter1.out -> internal.kIn;

                in -> internal.in;
                internal.out -> out;
            }
        }
    
        namespace Internal
        {   
            struct Coeffs
            {
                SampleType g; //G for onepole stages
                SampleType k; //resonance
                SampleType N; //nonlinearity
            }

            void updatePerSample (Coeffs& c, SampleType G_Onepole, SampleType k)
            {
                c.g = G_Onepole;
                c.k = k;
            }

            namespace M (int order)
            {
                static_assert (order % 2 == 0, "LadderFilter::M [[Filter Processors]]");

                void update (Coeffs& c, float nonlinearity, State& s, float64 fs)
                {
                    c.N = float (88200 / fs) * nonlinearity * (1.f + float (c.k[0])); //nonlinearity scaled according to fs and other params
                }

                struct State
                {
                    SampleType[order] s;
                }

                SampleType process (State& s, SampleType x, const Coeffs& c)
                {
                    var S = ZERO;
                    var G = ONE;
                    for (int i = order - 1; i > -1; --i)
                    {
                        S += G * s.s.at(i);
                        G *= c.g;
                    }

                    //input to first lowpass ('u')
                    var y = (x - c.k * S) / (ONE + c.k * G);

                    //'order' lowpasses in series
                    for (int i = 0; i < order; ++i)
                    {
                        let v = (y - s.s.at(i)) * c.g;
                        
                        y = vBBD(v  + s.s.at(i), c.N); // "state saturation"
                        s.s.at(i) = v + y;
                    }
                    
                    return y * (ONE + c.k); //normalize
                }
            }
        
            processor Processor (float iNonlinearity, int order = 4)
            {
                input stream SampleType in;
                output stream SampleType out;

                input stream SampleType G_OnepoleIn, kIn;

                input event float nonlinearityIn [[ name: "Nonlin", min: 0, max: 1, init: iNonlinearity, step: 0.01]];

                event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            
                float nonlinearity = iNonlinearity;
                bool recalc = true;

                static_assert (order == 4, "LadderLpfS::Processor [[Filter Processors]] Other filter orders not yet implemented.");
        
                void run()
                {   
                    M(order)::State s;
                    Coeffs c;

                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;

                            M(order)::update (c, nonlinearity, s, processor.frequency);
                        }

                        loop (updateIntervalSamples)
                        {
                            c.updatePerSample (G_OnepoleIn, kIn);                            

                            out << M(order)::process (s, in, c);

                            advance();
                        }
                    }
                }
            }
        }
    }

    /** Split into attack/release via IsolateAttackSustain */
    namespace SplitAttackSustain
    {
        graph Processor(float iAttack,
                        float iSustain,
                        float iSensitivity,
                        float iStereoLink)
        {
            input stream SampleType in;
            output stream SampleType attackOut, sustainOut;
    
            input
            {
                sustainIsolator.attackIn;
                sustainIsolator.sustainIn;
                sustainIsolator.sensitivityIn;
                sustainIsolator.stereoLinkIn;
            }
    
            let
            {
                sustainIsolator = SustainIsolator::Processor (iAttack, iSustain, iSensitivity, iStereoLink);

                difference = Difference::Processor;
            }
    
            connection
            {
                in -> sustainIsolator.in, difference.in;

                sustainIsolator.out -> difference.in1, sustainOut;

                difference.out -> attackOut;
            }
        }
    }

    /** First order HPF with cutoff at 1Hz */
    namespace DC_Blocker
    {
        graph Processor
        {
            input stream SampleType in;
            output stream SampleType out;
    
            let
            {
                dcBlocker = filt::dc_blocker::Processor (1);
            }
    
            connection
            {
                in -> dcBlocker -> out;
            }
        }
    }

    /** Ultrasonic blocker using a slightly over-damped svf 
    
        No overshoot
    */
    namespace UltraBlocker
    {
        graph Processor()
        {
            input stream SampleType in;
            output stream SampleType out;
    
            let
            {
                pSvf = filt::tpt::svf::Processor (16000, 0.4f);
            }
    
            connection
            {
                in -> pSvf.in;
                pSvf.lowpassOut -> out;
            }
        }
    }
    
    /** Split into high/low amplitude via downward compression or downward expansion */
    namespace SplitLoudSoft
    {
        graph Processor(float iThreshold,
                        float iRelease,
                        float iStereoLink)
        {
            input stream SampleType in;
            output stream SampleType loudOut, softOut;
    
            input
            {
                expressorClassical.thresholdIn;
                expressorClassical.releaseIn [[ name: "Release", min: 30, max: 999, init: iRelease, unit: "ms", step: 1 ]];
                expressorClassical.stereoLinkIn;
            }
    
            let
            {
                expressorClassical = ExpressorClassical::Processor (iStereoLink, 4, iRelease, iThreshold, 1, 0.25f);
                difference = Difference::Processor;
            }
    
            connection
            {
                in -> expressorClassical.in, difference.in;
                expressorClassical.out -> loudOut, difference.in1;

                difference.out -> softOut;
            }
        }
    }
    
    /** Isolate the attack or sustain using 'DET' 
    
        attackIn is actually the effective attack
        time + 4 ms
    */
    namespace SustainIsolator
    {
        graph Processor(float iAttack,
                        float iSustain,
                        float iSensitivity,
                        float iStereoLink)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                det.release0In sustainIn [[ name: "Sustain", min: 30, max: 200, init: iSustain, step: 1, unit: "ms" ]];
                det.release1In attackIn [[ name: "Attack", min: 4, max: 25, init: iAttack, step: 1, unit: "ms" ]];       
                smoothedVolume.volumeIn sensitivityIn [[ name: "Sens", min: 0, max: 36, init: iSensitivity, step: 1, unit: "dB" ]];
                stereoLink.stereoLinkIn;
            }
    
            let
            {
                absADAA = AbsADAA::Processor;
                stereoLink = StereoLink::Processor (iStereoLink);

                det = DET::Processor (4, iSustain, 4, iAttack);

                smoothedVolume = SmoothedVolume::Processor (iSensitivity);
                sigmoidC2 = SigmoidC2::Processor;

                applyGain = ApplyGain::Processor;
            }
    
            connection
            {
                in -> applyGain.in;

                in -> absADAA -> stereoLink.in;
                stereoLink.out -> det.in;
                det.out -> smoothedVolume.in;
                smoothedVolume.out -> sigmoidC2 -> applyGain.b;

                applyGain.out -> out;
            }
        }
    }

    /** Classical digital downwards/updawards ex(pander)/(com)pressor */
    namespace ExpressorClassical
    {
        graph Processor (float iStereoLink,
                        float iAttack,
                        float iRelease,
                        float iThreshold,
                        float iRatio0,
                        float iRatio1)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                stereoLink.stereoLinkIn;

                ballisticsFilter.attackIn;
                ballisticsFilter.releaseIn;

                ctf.thresholdIn;
                ctf.ratio0In;
                ctf.ratio1In;
            }
    
            let
            {
                absADAA = AbsADAA::Processor;
                stereoLink = StereoLink::Processor (iStereoLink);
                ballisticsFilter = BallisticsFilter::Processor (iAttack, iRelease);
                ctf = CTF::Processor (iThreshold, iRatio0, iRatio1);

                applyGain = ApplyGain::Processor;
            }
    
            connection
            {
                in -> applyGain.in;

                in -> absADAA -> stereoLink.in;
                stereoLink.out -> ballisticsFilter.in;
                ballisticsFilter.out -> ctf.in;
                ctf.out -> applyGain.b;

                applyGain.out -> out;
            }
        }
    }

    /** Differential Envelope Technology
    
        Notes:
        - Use case: transient detection (use for attack or sustain)
        - See: https://spl.audio/en/spl-produkt/transient-designer-4/?v=fa868488740a
        - Also see: https://blog.audio-tk.com/2015/06/30/audio-toolkit-anatomy-of-a-transient-shaper/
    */
    namespace DET
    {
        graph Processor(float iAttack0,
                        float iRelease0,
                        float iAttack1,
                        float iRelease1)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                ballisticsFilter0.attackIn attack0In;
                ballisticsFilter0.releaseIn release0In;
                ballisticsFilter1.attackIn attack1In;
                ballisticsFilter1.releaseIn release1In; 
            }
    
            let
            {
                ballisticsFilter0 = BallisticsFilter::Processor (iAttack0, iRelease0);
                ballisticsFilter1 = BallisticsFilter::Processor (iAttack1, iRelease1);

                difference = Difference::Processor;
            }
    
            connection
            {
                in -> ballisticsFilter0.in, ballisticsFilter1.in;

                ballisticsFilter0.out -> difference.in;
                ballisticsFilter1.out -> difference.in1;

                difference.out -> out;
            }
        }
    }

    /** Low pass filter with attack and release controls
    
        Notes:
        - TPT; all feedback loops are zero delay
        - Equivalent to 'OnepoleC' with differing cutoff depending on rising/falling instantaneous output vs input
    */
    namespace BallisticsFilter
    {
        let oversampling = 2;

        graph Processor(float iAttack,
                        float iRelease)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                unsmoothedParameter.in attackIn [[ name: "Attack", min: 0.5f, max: 50, init: iAttack, unit: "ms", step: 0.1 ]];
                unsmoothedParameter1.in releaseIn [[ name: "Release", min: 30, max: 3000, init: iRelease, unit: "ms", step: 1 ]];
            }
    
            let
            {
                unsmoothedParameter = UnsmoothedParameter::Processor(UnsmoothedParameter::ParameterType (iAttack), UnsmoothedParameter::ModeIdx::TauToOmega);
                unsmoothedParameter1 = UnsmoothedParameter::Processor(UnsmoothedParameter::ParameterType (iRelease), UnsmoothedParameter::ModeIdx::TauToOmega);
                
                internal = Internal::Processor * oversampling;
            }
    
            connection
            {
                unsmoothedParameter.out -> internal.attackIn;
                unsmoothedParameter1.out -> internal.releaseIn;

                in -> internal.in;
                internal.out -> out;
            }
        }
        
        namespace Internal
        {
            graph Processor()
            {
                input stream SampleType in, attackIn, releaseIn;
                output stream SampleType out;

                let
                {
                    branchingCutoff = BranchingCutoff::Processor;
                    onepoleC = OnepoleC::Processor;
                }
        
                connection
                {
                    attackIn -> branchingCutoff.attackIn;
                    releaseIn -> branchingCutoff.releaseIn;

                    in -> onepoleC.in, branchingCutoff.in;
                    onepoleC.stateOut -> [1] -> branchingCutoff.stateIn;
                    branchingCutoff.OmegaOut -> onepoleC.Omega;
                    onepoleC.lowpassOut -> out;
                }
            }
        }
    }
    
    /** Mix outputs from any Onepole-style filter to make more complicated frequency responses */
    namespace OnepoleMixer
    {   
        namespace ModeIdx
        {
            let LP = 0; //low pass
            let HP = 1; //high pass
            let AP = 2; //all pass
            let LS = 3; // low shelf
            let HS = 4; // high shelf
            let NumIdxs = 5;
        }

        struct Coeffs
        {
            int m;
            SampleType b;
        }
    
        void update (Coeffs& c, float modeIdx, float gain_dB)
        {
            c.m = int (modeIdx);
            c.b = vdBtoGain (SampleType (gain_dB));
        }
    
        SampleType process (SampleType hpf, SampleType lpf, const Coeffs& c)
        {
            if (c.m == ModeIdx::LP)
                return lpf;
            else if (c.m == ModeIdx::HP)
                return hpf;
            else if (c.m == ModeIdx::AP)
                return lpf - hpf;
            else if (c.m == ModeIdx::LS)
                return hpf + c.b * lpf;
            else if (c.m == ModeIdx::HS)
                return lpf +  c.b * hpf; 
            
            return ZERO;
        }
    
        processor Processor (int iModeIdx, float iGain_dB)
        {
            input stream SampleType lowpassIn, highpassIn;
            output stream SampleType out;
    
            input event float modeIn [[ name: "Mode", min: 0, init: iModeIdx, text: "LP|HP|AP|LS|HS" ]];
            input event float gainIn [[ name: "Gain", unit: "dB", min: -24, max: 24, step: 0.1f, init: iGain_dB ]];
    
            event modeIn (float v) { mode = v; recalc = true; }
            event gainIn (float v) { gain_dB = v; recalc = true; }
    
            float mode = float (iModeIdx);
            float gain_dB = iGain_dB;
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (mode, gain_dB);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (highpassIn, lowpassIn, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Onepole-style filter based on slew rate lowpass (nonlinear) */
    namespace OnepoleSlew
    {
        graph Processor(float iSlewMax_dB)
        {
            input stream SampleType in;
            output stream SampleType lowpassOut, highpassOut;
    
            input
            {
                slewLimiter.slewMaxIn;
            }
    
            let
            {
                differentiator = Integrator(true)::Processor;
                slewLimiter = SlewLimiter::Processor (iSlewMax_dB);
                integrator = Integrator::Processor;

                difference = Difference::Processor;
            }
    
            connection
            {
                in -> differentiator.in, difference.in;
                differentiator.out -> slewLimiter.in;
                slewLimiter.out -> integrator.in;
                integrator.out -> difference.in1, lowpassOut;

                difference.out -> highpassOut;
            }
        }
    }
    
    /** soul::filters::tpt::onepole modified for angular cutoff modulation
        
        - If sampling rate is 44.1kHz and an accurate frequency response is important, use 2x oversampling
        - Structure is more consistent with SVF and oversampling is used instead of prewarping when compared to soul::filters::tpt::onepole
    */
    namespace OnepoleC
    {   
        struct Coeffs
        {
            SampleType G;
        }

        struct State
        {
            SampleType s;
        }

        void updatePerSample (Coeffs& c, SampleType Omega, float64 fs)
        {
            c.G = vOmegaToG_Onepole (Omega, fs);
        }

        SampleType[3] process (State& s, SampleType x, const Coeffs& c)
        {
            let v = (x - s.s) * c.G;
            let lpf = v + s.s;
            let hpf = x - lpf;

            s.s = v + lpf;

            return SampleType[3] (lpf, hpf, s.s);
        }

        processor Processor
        {
            input stream SampleType in;
            input stream SampleType Omega;
            output stream SampleType lowpassOut, highpassOut;
            output stream SampleType stateOut;

            void run()
            {   
                State s;
                Coeffs c;

                loop
                {
                    c.updatePerSample (Omega, processor.frequency);

                    let y = process (s, in, c);

                    lowpassOut << y.at(0);
                    highpassOut << y.at(1);
                    stateOut << y.at(2);

                    advance();
                }
            }
        }
    }

    /** Modified version of https://soul.dev/lab/?id=Delay 
    
        For feedback make a loop with a unit delay (i.e. DelayLine.out -> [1] -> ${1:add your effects here} -> DelayLine.in)
    */
    namespace DelayLine
    {   
        namespace M (float maxDelayMs, float maxDepthMs)
        {
            static_assert ((maxDelayMs + maxDepthMs) < float (INT_MAX_BUFFER_SIZE_MS), "DelayLine::M [[Filter Processors]]");
            
            let maxBufferSize = int (ceil (((maxDelayMs + maxDepthMs) / float (INT_MAX_BUFFER_SIZE_MS)) * float (INT_MAX_BUFFER_SIZE)));

            struct State 
            {
                wrap<maxBufferSize> readPos, writePos;
                SampleType[maxBufferSize] buf;
            }

            void update (State& s, float delayMs, float64 fs)
            {
                let fsDiv1k = fs / 1000.f;

                s.readPos = wrap<maxBufferSize> (s.writePos - int (fsDiv1k * delayMs));
            }

            SampleType process (State& s, SampleType x, SampleType lfo, float64 fs)
            {
                let maxDepthSamples = float64 (maxDepthMs * fs / 1000.0);

                s.buf.at (s.writePos) = x;

                let l = s.buf.readLinearInterpolated (float64 (s.readPos) - maxDepthSamples * lfo[0]);
                let r = s.buf.readLinearInterpolated (float64 (s.readPos) - maxDepthSamples * lfo[1]);
                
                let y = l * CHANNEL_ZERO_MASK + r * CHANNEL_ONE_MASK;

                ++s.readPos;
                ++s.writePos;

                return y;
            }
        }

        processor Processor (float iDelayMs, float maxDelayMs, float maxDepthMs = 4)
        {
            input stream SampleType in;
            output stream SampleType out;

            input stream SampleType lfoIn; //unipolar, <= 1

            input event float delayIn [[ name: "Delay", min: 0, max: maxDelayMs, init: iDelayMs, unit: "ms", step: 1 /*UNSMOOTHED*/ ]];

            event delayIn (float v) { delayMs = v; recalc = true; }

            float delayMs = iDelayMs;
            bool recalc = true;

            static_assert (iDelayMs <= maxDelayMs, "DelayLine::Processor [[Filter Processors]]");

            namespace m = M (maxDelayMs, maxDepthMs);

            void run()
            {  
                m::State s;
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                if (processor.frequency < 48001)
                {
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
        
                            m::update (s, delayMs, processor.frequency);
                        }
        
                        loop (updateIntervalSamples)
                        {
                            out << m::process (s, in, lfoIn, processor.frequency);

                            advance();
                        }
                    }
                }
            }
        }
    }
    
/*==============================================================================
Vectorized Instrinsic/Helper Processors                                 02/24/22
==============================================================================*/
    
    /** Branching Cutoff for TPT Ballistics Filter */
    namespace BranchingCutoff
    {
        graph Processor()
        {
            input stream SampleType in, stateIn, attackIn, releaseIn;
            output stream SampleType OmegaOut;
    
            let
            {
                sum = Sum::Processor;
                difference = Difference::Processor;
                difference1 = Difference::Processor;
                applyGain = ApplyGain::Processor;

                step = Step::Processor;
            }
    
            connection
            {
                //apply branching via step
                in -> difference.in;
                stateIn -> difference.in1;
                difference.out -> step.in;

                //scale and bias step
                attackIn -> difference1.in;
                releaseIn -> difference1.in1, sum.in;
                difference1.out -> applyGain.b;
                step.out -> applyGain.in;
                applyGain.out -> sum.in1;
                sum.out -> OmegaOut;
            }
        }
    }

    /** 'vStep' wrapper */
    namespace Step
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << vStep (in);

                    advance();
                }
            }
        }
    }
    
    /** 'vCTF_Color' wrapper */
    namespace CTF_Color
    {
        graph Processor(float iThreshold,
                        float iRatio0,
                        float iRatio1,
                        float iSoftness,
                        float iColor)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                smoothedParameter0.in thresholdIn [[ name: "Thresh", min: -50.f, max: 0.f, init: iThreshold, unit: "dB", step: 0.1f]];
                smoothedParameter1.in ratio0In [[ name: "Ratio (> Thr)", min: 0.5f, max: 20.f, init: iRatio0, step: 0.1f ]];
                smoothedParameter2.in ratio1In [[ name: "Ratio (< Thr)", min: 0.5f, max: 1.5f, init: iRatio1, step: 0.1f ]];
                smoothedParameter3.in softnessIn [[ name: "Softness", min: 0, max: 24, init: iSoftness, unit: "dB", step: 0.1f ]];
                smoothedParameter4.in colorIn [[ name: "Color", min: -24, max: 24, init: iColor, unit: "dB", step: 0.1f ]]; 
            }
    
            let
            {
                smoothedParameter0 = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iThreshold), SmoothedParameter::ModeIdx::DecibelToDecibel);
                smoothedParameter1 = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iRatio0), SmoothedParameter::ModeIdx::RatioToRatio);
                smoothedParameter2 = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iRatio1), SmoothedParameter::ModeIdx::RatioToRatio);
                smoothedParameter3 = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iSoftness), SmoothedParameter::ModeIdx::DecibelToDecibel);
                smoothedParameter4 = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iColor), SmoothedParameter::ModeIdx::DecibelToDecibel);

                internal = Internal::Processor;
            }
    
            connection
            {
                smoothedParameter0.out -> internal.thresholdIn;
                smoothedParameter1.out -> internal.ratio0In;
                smoothedParameter2.out -> internal.ratio1In;
                smoothedParameter3.out -> internal.softnessIn;
                smoothedParameter4.out -> internal.colorIn;

                in -> internal.in;
                internal.out -> out;
            }
        }

        namespace Internal
        {
            struct Coeffs 
            {
                SampleType threshold;
                SampleType ratio0;
                SampleType ratio1;
                SampleType softness;
                SampleType color; 
            }
        
            void updatePerSample (Coeffs& c, SampleType threshold, SampleType ratio0, SampleType ratio1, SampleType softness, SampleType color) 
            {
                c.threshold = threshold;
                c.ratio0 = ratio0;
                c.ratio1 = ratio1;
                c.softness = softness;
                c.color = color;
            }
        
            SampleType process (SampleType x, const Coeffs& c) 
            {
                return vCTF_Color (x, c.threshold, c.ratio0, c.ratio1, c.softness, c.color);
            }

            processor Processor()
            {
                input stream SampleType in;
                input stream SampleType thresholdIn, ratio0In, ratio1In, softnessIn, colorIn;
                output stream SampleType out;

                void run()
                {
                    Coeffs c;

                    loop
                    {
                        c.updatePerSample (thresholdIn, ratio0In, ratio1In, softnessIn, colorIn);

                        out << process (in, c);
    
                        advance();
                    
                    }
                }
            }
        }
    }

    /** 'vCTF' wrapper */
    namespace CTF
    {
        graph Processor(float iThreshold,
                        float iRatio0,
                        float iRatio1)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                smoothedParameter0.in thresholdIn [[ name: "Thresh", min: -50.f, max: 0.f, init: iThreshold, unit: "dB", step: 0.1f]];
                smoothedParameter1.in ratio0In [[ name: "Ratio (> Thr)", min: 0.5f, max: 20.f, init: iRatio0, step: 0.1f ]];
                smoothedParameter2.in ratio1In [[ name: "Ratio (< Thr)", min: 0.5f, max: 1.5f, init: iRatio1, step: 0.1f ]];
            }
    
            let
            {
                smoothedParameter0 = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iThreshold), SmoothedParameter::ModeIdx::DecibelToDecibel);
                smoothedParameter1 = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iRatio0), SmoothedParameter::ModeIdx::RatioToRatio);
                smoothedParameter2 = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iRatio1), SmoothedParameter::ModeIdx::RatioToRatio);

                internal = Internal::Processor;
            }
    
            connection
            {
                smoothedParameter0.out -> internal.thresholdIn;
                smoothedParameter1.out -> internal.ratio0In;
                smoothedParameter2.out -> internal.ratio1In;

                in -> internal.in;
                internal.out -> out;
            }
        }
        
        namespace Internal
        {
            struct Coeffs 
            {
                SampleType threshold;
                SampleType ratio0;
                SampleType ratio1;
            }
        
            void updatePerSample (Coeffs& c, SampleType threshold, SampleType ratio0, SampleType ratio1) 
            {
                c.threshold = threshold;
                c.ratio0 = ratio0;
                c.ratio1 = ratio1;
            }
        
            SampleType process (SampleType x, const Coeffs& c) 
            {
                return vCTF (x, c.threshold, c.ratio0, c.ratio1);
            }

            processor Processor()
            {
                input stream SampleType in;
                input stream SampleType thresholdIn, ratio0In, ratio1In;
                output stream SampleType out;

                void run()
                {
                    Coeffs c;
                
                    loop
                    {
                        c.updatePerSample (thresholdIn, ratio0In, ratio1In);

                        out << process (in, c);

                        advance();
                    }
                }
            }
        }
    }

    /** Split into center/sides using StereoLink */
    namespace SplitCenterSides
    {
        graph Processor (float iCenterSides)
        {
            input stream SampleType in;
            output stream SampleType centerOut, sidesOut;
    
            input
            {
                stereoLink.stereoLinkIn centerSidesIn [[ name: "Split Amount", min: 0, max: 100, init: iCenterSides, unit: "%", step: 1 ]];
            }
    
            let
            {
                stereoLink = StereoLink::Processor (iCenterSides);
                difference = Difference::Processor;
            }
    
            connection
            {
                in -> stereoLink.in, difference.in;
                stereoLink.out -> difference.in1, centerOut;

                difference.out -> sidesOut;
            }
        }
    }

    /** 'vStereoLink' wrapper */
    namespace StereoLink
    {   
        struct Coeffs
        {
            float stereoLink;
        }
    
        void update (Coeffs& c, float stereoLink)
        {
            c.stereoLink = stereoLink;
        }
    
        SampleType process (SampleType x, const Coeffs& c)
        {
            return vStereoLink (x, c.stereoLink);
        }
    
        processor Processor (float iStereoLink)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float stereoLinkIn [[ name: "Link", min: 0, max: 100, init: iStereoLink, unit: "%", step: 1 ]];
            
            event stereoLinkIn (float v) { stereoLink = v; recalc = true; }

            float stereoLink = iStereoLink;
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency/44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (stereoLink);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** 'vLan' wrapper with ADAA and a linear angular cutoff of 2pi
    
        Notes:
        - Optimized for use with 'OnepoleC' or modulating frequency domain filters
        - Use with 2x oversampling
    */
    namespace LanADAA
    {   
        struct Coeffs
        {
            SampleType N;
        }
    
        void update (Coeffs& c, float nonlinearity)
        {
            c.N = SampleType (nonlinearity);
        }    
    
        SampleType f (SampleType x, const Coeffs& c)
        {
            return vLan (x, c.N);
        }
    
        SampleType F1 (SampleType x, const Coeffs& c)
        {
            return vpow (x, 3) * vpow (c.N, 2) * SampleType (1.0 / 3.0) + c.N * vpow (x, 2) * vSgn (x) + x;
        }
    
        SampleType F2 (SampleType x, const Coeffs& c)
        {
            return vpow (x, 2) * (HALF + c.N * SampleType (1.0 / 3.0) * x * vSgn (x) + vpow (c.N, 2) * SampleType (1.0 / 12.0) * vpow (x, 2));
        }
    
        struct State
        {
            SampleType x_2;
            SampleType x_1;
            SampleType F2_1;
            SampleType F1_1;
        }
    
        void reset (State& s)
        {
            s.x_2 = ZERO;
            s.x_1 = ZERO;
            s.F2_1 = ZERO;
            s.F1_1 = ZERO;
        }

        SampleType processADAA2 (State& s, SampleType x, const Coeffs& c)
        {
            //Find F1_0
            let x_0mx_1 = x - s.x_1;
            let F2_0 = F2 (x, c);
    
            let F1_0 = viflt (F1 (HALF * (x + s.x_1), c), 
                (F2_0 - s.F2_1) / x_0mx_1,
                vabs (x_0mx_1), DIV_TOL);
    
            //Find f_0
            let x_0mx_2 = x - s.x_2;
    
            let xBar = HALF * (x + s.x_2);
            let delta = xBar - s.x_1;
    
            let f_0 = viflt (
                viflt (
                    f (HALF * (xBar + s.x_1), c),
                    (TWO / delta) * (F1 (xBar, c) + (s.F2_1 - F2 (xBar, c)) / delta),
                    vabs (delta), DIV_TOL
                ),
                (TWO / (x_0mx_2)) * (F1_0 - s.F1_1),
                vabs (x_0mx_2), DIV_TOL
            );
    
            //update s
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType process (State& s, SampleType x, const Coeffs& c)
        {
            return s.processADAA2 (x, c);
        }
    
        processor Processor (float iNonlinearity)
        {
            input stream SampleType in;
            output stream SampleType Omega;

            input event float nonlinearityIn [[ name: "Nonlin", min: 0, max: 350, init: iNonlinearity, step: 1 /*UNSMOOTHED*/ ]];

            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            
            float nonlinearity = iNonlinearity;
            bool recalc = true;

            void run()
            {
                State s;
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (nonlinearity);
                        s.reset();
                    }

                    loop (updateIntervalSamples)
                    {
                        Omega << (SampleType (twoPi - 1) + s.process (in, c));

                        advance();
                    }
                }
            }
        }
    }

    /** Limit Slew rate using sigmoidC2*/
    namespace SlewLimiter
    {   
        graph Processor (float iSlewMax_dB)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                smoothedParameter.in slewMaxIn;
            }
    
            let
            {
                applyGain = ApplyGain::Processor;
                applyGain1 = ApplyGain::Processor;
                sigmoidC2 = SigmoidC2::Processor;

                integrator = Integrator::Processor;
                differentiator = Integrator(true)::Processor;

                smoothedParameter = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iSlewMax_dB, 0, 0, 0), SmoothedParameter::ModeIdx::DecibelToGainAndReciprocal);
            }
    
            connection
            {
                smoothedParameter.out -> applyGain.b; //pre sigmoid
                smoothedParameter.out1 -> applyGain1.b; //post sigmoid

                in -> differentiator.in;
                differentiator.out -> applyGain.in;
                applyGain.out -> sigmoidC2 -> applyGain1.in;
                applyGain1.out -> integrator.in;
                integrator.out -> out;
            }
        }  
    }

    /** 'vSigmoidC2' wrapper */
    namespace SigmoidC2
    {   
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;
    
            void run()
            {   
                loop
                {
                    out << vSigmoidC2 (in);

                    advance();
                }
            }
        }
    }

    /** 'vabs' wrapper with ADAA
    
        Notes:
        - ADAA specifically optimized for signal rectification (see 'TheExpressor' and 'ExpressorClassical')
    */
    namespace AbsADAA (int order = 2)
    {   
        static_assert (order > -1 && order < 4, "AbsADAA [[ Vectorized Instrinsic/Helper Processors ]]");
        let oversampling = (order < 3 ? 2 : 4); 

        struct Coeffs
        {
        }

        SampleType f (SampleType x, const Coeffs& c)
        {
            return vabs (x);
        }
    
        SampleType F1 (SampleType x, const Coeffs& c)
        {
            return vSgn(x) * HALF * vpow (x, 2);
        }
    
        SampleType F2 (SampleType x, const Coeffs& c)
        {
            return vSgn (x) * SampleType (1.0 / 6.0) * vpow (x, 3);
        }
    
        SampleType F3 (SampleType x, const Coeffs& c)
        {
            return vSgn(x) * SampleType (1.0 / 24.0) * vpow (x, 4);
        }

        graph Processor()
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                //Endpoint declarations
            }
    
            let
            {
                internal = Internal::Processor * oversampling;
            }
    
            connection
            {
                in -> internal -> out;
            }
        }


        // SampleType processADAA2 (State& s, SampleType x, const Coeffs& c)
        // {
        //     //Find F1_0
        //     let div = x - s.x.at(1);
        //     s.F_0.at(2) = F2 (x, c);
    
        //     s.F_0.at(1) = viflt (F1 (HALF * (x + s.x.at(1)), c), 
        //         (s.F_0.at(2) - s.F_1.at(2)) / div,
        //         vabs (div), DIV_TOL);
    
        //     //Find f_0
        //     let div2 = x - s.x.at(2);
    
        //     let xBar = HALF * (x + s.x.at(2));
        //     let delta = xBar - s.x.at(1);
    
        //     s.F_0.at(0) = viflt (
        //         viflt (
        //             f (HALF * (xBar + s.x.at(1)), c),
        //             (TWO / delta) * (F1 (xBar, c) + (s.F_1.at(2) - F2 (xBar, c)) / delta),
        //             vabs (delta), DIV_TOL
        //         ),
        //         (TWO / div2) * (s.F_0.at(1) - s.F_1.at(1)),
        //         vabs (div2), DIV_TOL
        //     );
    
        //     //update s
        //     s.x.at(2) = s.x.at(1);
        //     s.x.at(1) = x;
        //     s.F_1.at(2) = s.F_0.at(2);
        //     s.F_1.at(1) = s.F_0.at(1);
    
        //     return s.F_0.at(0);
        // }
    
        // SampleType processADAA1 (State& s, SampleType x, const Coeffs& c)
        // {
        //     //Find f_0
        //     let x_0mx_1 = x - s.x_1;
        //     let F1_0 = F1 (x, c);
    
        //     let f_0 = viflt (f (HALF * (x + s.x_1), c), 
        //         (F1_0 - s.F1_1) / x_0mx_1,
        //         vabs (x_0mx_1), DIV_TOL);
    
        //     //update s
        //     s.x_1 = x;
        //     s.F1_1 = F1_0;
    
        //     return f_0;
        // }
        
        namespace Internal
        {
            SampleType F (int o, SampleType x, const Coeffs& c)
            {
                if (o == 0)
                    return f (x, c);
                else if (o == 1)
                    return F1 (x, c);
                else if (o == 2)
                    return F2 (x, c);
                else if (o == 3)
                    return F3 (x, c);
                else
                    return ZERO;
            }

            struct State
            {
                SampleType[order + 1] x; //x.at(i) <-> x*z^-i
                SampleType[order + 1] F_0; //F.at(i) <-> F(i, x, c)
                SampleType[order + 1] F_1; //F_1.at(i) <-> F(i + 1, x, c)*z^-1
            }

            void reset (State& s)
            {
                s = State();
            }
        
            SampleType process (State& s, SampleType x, const Coeffs& c)
            {
                let o = order;

                s.x.at(0) = x;
                s.F_0.at(o) = F (o, s.x.at(0), c);

                //derive 'order' times starting with antiderivative of order 'order'
                for (int i = 1; i < order + 1; ++i)
                {
                    let n = (i - 1)/2; //each 2 orders adds a sample delay
                    let co = o - i + 1; //current order
                    
                    if ((i & 1) == 1) //odd derivative
                    {
                        let div = s.x.at(n) - s.x.at(n+1);

                        s.F_0.at(co-1) = viflt (
                            F(co-1, HALF * (s.x.at(n) + s.x.at(n + 1)), c), 
                            (s.F_0.at(co) - s.F_1.at(co)) / div,
                            vabs (div), 
                            DIV_TOL
                        ); 
                    }
                    else //even iteration
                    {
                        let div2 = s.x.at(n) - s.x.at(n+2);
                
                        let xBar = HALF * (s.x.at(n) + s.x.at(n+2));
                        let delta = xBar - s.x.at(n+1);
                
                        s.F_0.at(co-1) = viflt (
                            viflt (
                                F (co-1, HALF * (xBar + s.x.at(n+1)), c),
                                (TWO / delta) * (F (co ,xBar, c) + (s.F_1.at(co+1) - F (co+1, xBar, c)) / delta),
                                vabs (delta),
                                DIV_TOL
                            ),
                            (TWO / div2) * (s.F_0.at(co) - s.F_1.at(co)),
                            vabs (div2), 
                            DIV_TOL
                        );
                    }
                }

                //update state
                for (int i = int (s.x.size - 1); i > 0; --i)
                    s.x.at(i) = s.x.at(i - 1);

                s.F_1 = s.F_0;

                return s.F_0.at(0);
            }

            processor Processor()
            {
                input stream SampleType in;
                output stream SampleType out;

                void run()
                {
                    State s;
                    Coeffs c;
        
                    loop
                    {
                        out << s.process (in, c);

                        advance();
                    }
                }
            }
        }
    }
    
    namespace Abs
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << vabs (in);

                    advance();
                }
            }
        }
    }

    namespace PhaseInverts
    {
        graph Processor(bool iInvertL_Bool, bool iInvertR_Bool)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                unsmoothedParameter.in invertR_In;
                unsmoothedParameter.in1 invertL_In;
            }
    
            let
            {
                unsmoothedParameter = UnsmoothedParameter::Processor (UnsmoothedParameter::ParameterType (float (iInvertL_Bool), float (iInvertR_Bool)), UnsmoothedParameter::ModeIdx::PhaseInverts);
                applyGain = ApplyGain::Processor;
            }
    
            connection
            {
                unsmoothedParameter.out -> applyGain.b;

                in -> applyGain.in;

                applyGain -> out;
            }
        }
    }

    namespace PhaseInvert
    {
        graph Processor(bool iInvert_Bool)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                unsmoothedParameter.in invertIn;
            }
    
            let
            {
                unsmoothedParameter = UnsmoothedParameter::Processor (UnsmoothedParameter::ParameterType (float (iInvert_Bool), 0), UnsmoothedParameter::ModeIdx::PhaseInvert);
                applyGain = ApplyGain::Processor;
            }
    
            connection
            {
                unsmoothedParameter.out -> applyGain.b;

                in -> applyGain.in;

                applyGain -> out;
            }
        }
    }

    /** out = b * in */
    namespace ApplyGain
    {
        processor Processor
        {
            input stream SampleType b;
            input stream SampleType in;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << b * in;
    
                    advance();
                }
            }
        }
    }

    /** out = b * in + b1 * in1 */
    namespace ApplyGains
    {
        processor Processor
        {
            input stream SampleType b, b1;
            input stream SampleType in, in1;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << b * in + b1 * in1;
    
                    advance();
                }
            }
        }
    }

    /** Output 1 of 4 signals */
    namespace Mux4To1
    {   
        struct Coeffs
        {
            int idx;
        }
    
        void update (Coeffs& c, float idx)
        {
            c.idx = int (idx);
        }
    
        SampleType process (SampleType[4] x, const Coeffs& c)
        {
            return x.at (c.idx);
        }
    
        processor Processor (int iIdx)
        {
            input stream SampleType in, in1, in2, in3;
            output stream SampleType out;
    
            input event float idxIn [[ name: "idx", min: 0, max: 3, init: iIdx, step: 1 /*UNSMOOTHED*/ ]];
    
            event idxIn (float v) { idx = v; recalc = true; }
    
            float idx = float (iIdx);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (idx);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (SampleType[4] (in, in1, in2, in3), c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Output 1 of 3 signals depending on processor.frequency (fs) 
    
        Input streams correspond to the the following common fs ranges in kHz:
        - in: 44.1, 48
        - in1: 88.2, 96
        - in2: 176.4, 192
    */
    namespace Mux3To1Fs
    {
        struct Coeffs
        {
            int idx;
        }
    
        void update (Coeffs& c, float64 fs)
        {
            if (fs > 96001.0)
                c.idx = 2;
            else if (fs > 48001.0)
                c.idx = 1;
            else 
                c.idx = 0;
        }

        SampleType process (SampleType[3] x, const Coeffs& c)
        {
            return x.at (c.idx);
        }
    
        processor Processor()
        {
            input stream SampleType in, in1, in2;
            output stream SampleType out;
    
            void run()
            {   
                Coeffs c;

                c.update (processor.frequency);

                loop
                {
                    out << process (SampleType[3] (in, in1, in2), c);

                    advance();
                }
            }
        }
    }
    
    /** Output 1 of 3 signals */
    namespace Mux3To1
    {   
        struct Coeffs
        {
            int idx;
        }
    
        void update (Coeffs& c, float idx)
        {
            c.idx = int (idx);
        }
    
        SampleType process (SampleType[3] x, const Coeffs& c)
        {
            return x.at (c.idx);
        }
    
        processor Processor (int iIdx)
        {
            input stream SampleType in, in1, in2;
            output stream SampleType out;
    
            input event float idxIn [[ name: "idx", min: 0, max: 2, init: iIdx, step: 1 /*UNSMOOTHED*/ ]];
    
            event idxIn (float v) { idx = v; recalc = true; }
    
            float idx = float (iIdx);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (idx);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (SampleType[3] (in, in1, in2), c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Output 1 of 2 signals */
    namespace Mux2To1
    {   
        struct Coeffs
        {
            int idx;
        }
    
        void update (Coeffs& c, float idx)
        {
            c.idx = int (idx);
        }
    
        SampleType process (SampleType[2] x, const Coeffs& c)
        {
            return x.at (c.idx);
        }
    
        processor Processor (bool iIdx)
        {
            input stream SampleType in, in1;
            output stream SampleType out;
    
            input event float idxIn [[ name: "idx", init: float (iIdx), boolean /*UNSMOOTHED*/ ]];
    
            event idxIn (float v) { idx = v; recalc = true; }
    
            float idx = float (iIdx);
            bool recalc = true;
    
            void run()
            {    
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (idx);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (SampleType[2] (in, in1), c);
    
                        advance();
                    }
                }
            }
        }
    }

    namespace Max
    {   
        processor Processor()
        {
            input stream SampleType a, b;
            output stream SampleType out;

            void run()
            {   
                loop
                {
                    out << vmax (a, b);

                    advance();
                }
            }
        }
    }

    namespace Sum
    {
        processor Processor()
        {
            input stream SampleType in, in1;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << in + in1;

                    advance();
                }
            }
        }
    }
    
    namespace Difference
    {
        processor Processor()
        {
            input stream SampleType in, in1;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << in - in1;

                    advance();
                }
            }
        }
    }

    /** A TDF-II Integrator with an implied input gain of 1 
    
        If inverse == true, do the inverse operation (differentiation)
    */
    namespace Integrator (bool inverse = false)
    {   
        struct State
        {
            SampleType s;
        }

        SampleType[2] process (State& s, SampleType x)
        {   
            if const (inverse)
            {
                let y = x - s.s;

                s.s = x + y;
                return SampleType[2] (y, s.s);
            } 
            else
            {
                let y = x + s.s; 

                s.s = x + y;
                return SampleType[2] (y, s.s);
            } 
        }

        processor Processor
        {
            input stream SampleType in;
            output stream SampleType out, sOut;

            void run()
            {   
                State s;

                loop
                {
                    let y = s.process (in);

                    out << y.at(0);
                    sOut << y.at(1);

                    advance();
                }
            }
        }
    }

/*==============================================================================
Mix Processors                                                          03/01/22
==============================================================================*/
    
    /** Apply a volume via 'AutoParameter' and 'SmoothedVolume' */
    namespace AutoSmoothedVolume
    {
        graph Processor(int mode)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                autoParameter.parameterIn;
                autoParameter.controlIn;
            }
    
            let
            {
                autoParameter = AutoParameter::Processor (mode);
                smoothedVolume = SmoothedVolume::Processor (AutoParameter::M(mode)::iParameter);
            }
    
            connection
            {
                autoParameter.out -> smoothedVolume.volumeIn;

                in -> smoothedVolume.in;
                smoothedVolume.out -> out;
            }
        }
    }

    /** Apply mixing and panning via 'SmoothedParameter' */
    namespace SmoothedMixPan
    {
        graph Processor(float iMix, float iPan)
        {
            input stream SampleType dryIn, wetIn;
            output stream SampleType out;
    
            input
            {
                smoothedGains.in mixIn [[ name: "Mix", min: 0, max: 100, init: iMix, unit: "%", step: 1 ]];
                smoothedGains.in1 panIn [[ name: "Pan", min: -1, max: 1, init: iPan, step: 0.01f ]];
            }

            let
            {
                smoothedGains = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iMix, iPan, 0, 0), SmoothedParameter::ModeIdx::MixPanToGains);
                applyGains = ApplyGains::Processor;
            }
    
            connection
            {
                smoothedGains.out -> applyGains.b;
                smoothedGains.out1 -> applyGains.b1;

                dryIn -> applyGains.in;
                wetIn -> applyGains.in1;

                applyGains.out -> out;
            }
        }
    }
    
    /** Apply makeup, mixing and panning via 'SmoothedParameter' */
    namespace SmoothedMakeupMixPans
    {
        graph Processor(float iMakeup, float iMix, float iPanDry, float iPanWet)
        {
            input stream SampleType in, wetIn;
            output stream SampleType out;
    
            input
            {
                smoothedParameter.in makeupIn [[ name: "Makeup", min: -24, max: 24, init: iMakeup, unit: "dB", step: 0.1 ]];
                smoothedParameter.in1 mixIn [[ name: "Mix", min: 0, max: 100, init: iMix, unit: "%", step: 1 ]];
                smoothedParameter.in2 panDryIn [[ name: "Dry Pan", min: -1, max: 1, init: iPanDry, step: 0.01f ]];
                smoothedParameter.in3 panWetIn [[ name: "Wet Pan", min: -1, max: 1, init: iPanWet, step: 0.01f ]];
            }

            let
            {
                smoothedParameter = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iMakeup, iMix, iPanDry, iPanWet), SmoothedParameter::ModeIdx::MakeupMixPansToGains);
                applyGains = ApplyGains::Processor;
            }
    
            connection
            {
                smoothedParameter.out -> applyGains.b;
                smoothedParameter.out1 -> applyGains.b1;

                in -> applyGains.in;
                wetIn -> applyGains.in1;

                applyGains.out -> out;
            }
        }
    }

    /** Apply a volume via 'SmoothedParameter' */
    namespace SmoothedVolume
    {
        graph Processor (float iVolume)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float volumeIn [[ name: "Volume", min: -12, max: 0, init: iVolume, step: 0.1f, unit: "dB" ]];
    
            let
            {
                smoothedGain = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iVolume), SmoothedParameter::ModeIdx::DecibelToGain);
                applyGain = ApplyGain::Processor;
            }
    
            connection
            {
                in -> applyGain.in;
                
                volumeIn -> smoothedGain.in;
                smoothedGain.out -> applyGain.b;

                applyGain.out -> out;
            }
        }
    }

/*==============================================================================
Parameter Processors                                                    03/04/22
==============================================================================*/

    /** Modified version of soul::oscillators::lfo 
    
        Notes:
        - Stereo output with ability to shift phase of the left channel ('widthIn')
        - Unipolar only
        - No beat sync or random lfos
    */
    namespace Lfo
    {   
        namespace Modes
        {
            let Triangle = 0;
            let Sine = 1;
            let NumModes = 2;
        }

        graph Processor (float iDepth,
                        float iRate,
                        float iWidth,
                        int iMode)
        {
            output stream SampleType out;
    
            input
            {
                smoothedParameter0.in depthIn [[ name: "Depth", min: 0, max: 100, init: iDepth, unit: "%", step: 1 ]];
                internal.rateIn;
                internal.widthIn;
                internal.modeIn;
            }
    
            let
            {
                smoothedParameter0 = SmoothedParameter::Processor (SmoothedParameter::ParameterType (iDepth), SmoothedParameter::ModeIdx::PercentToGain);
                
                internal = Internal::Processor (iRate, iWidth, iMode);
            }
    
            connection
            {
                smoothedParameter0.out -> internal.depthIn;

                internal.out -> out;
            }
        }

        namespace Internal
        {

            struct Coeffs
            {
                SampleType depth;
                SampleType phaseIncrement;
                int mode;
            }

            struct State
            {
                SampleType phase;
            }

            void updatePerSample (Coeffs& c, SampleType depth)
            {
                c.depth = depth;
            }

            void update (Coeffs& c, float rate, float width, float mode, State& s, float64 fs)
            {
                let T = 1.0 / fs;

                c.phaseIncrement = SampleType (rate * T);
                
                s.phase[0] = s.phase[1] + float64 (width * (1.f / 360.f));
                while (s.phase[0] < 0.0)
                    s.phase[0] += 1.0;
                while (s.phase[0] >= 1.0)
                    s.phase[0] -= 1.0;

                c.mode = int (mode);
            }

            SampleType process (State& s, const Coeffs& c)
            {
                var y = ZERO;

                if (c.mode == Modes::Triangle)      
                    y = ONE - vabs((s.phase * TWO) - ONE );
                else if (c.mode == Modes::Sine)          
                    y = (sin (s.phase * SampleType (twoPi)) + ONE) * HALF;

                s.phase += c.phaseIncrement;

                while (s.phase[0] >= 1.0)
                    s.phase[0] -= 1.0;
                while (s.phase[1] >= 1.0)
                    s.phase[1] -= 1.0;
            
                return y * c.depth;
            }

            processor Processor (float iRate,
                                 float iWidth,
                                 int iMode)
            {
                output stream SampleType out;
                
                input stream SampleType depthIn;

                input event
                {
                    float rateIn [[ name: "Rate", min: 0.1, max: 4, init: iRate, unit: "Hz", step: 0.01 ]];
                    float widthIn [[ name: "Width", min: -180, max: 180, init: iWidth, unit: "deg", step: 1 /*UNSMOOTHED*/ ]];
                    float modeIn [[ name: "Mode", min: 0, init: iMode, text: "Tri|Sine" /*UNSMOOTHED*/ ]];
                }

                event rateIn (float v) { rate = v; recalc = true; }
                event widthIn (float v) { width = v; recalc = true; }
                event modeIn (float v) { mode = v; recalc = true; }

                float rate = iRate;
                float width = iWidth;
                float mode = float (iMode);

                bool recalc = true;

                void run()
                {
                    State s;
                    Coeffs c;

                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;

                            c.update (rate, width, mode, s, processor.frequency);
                        }

                        loop (updateIntervalSamples)
                        {          
                            c.updatePerSample (depthIn);

                            out << process (s, c);

                            advance();
                        }
                    }
                }
            }
        }
    }

    /** Automatic/manual parameters

        Notes:
        - Use to control a event float endpoint
        - Passes events from 'parameterIn' to 'out' unless the current value of 'parameterIn' is below the mode's MinManualParameter.
        'controlIn' is mapped to 'out' in this case ('out' is automatically determined by 'controlIn')
        - Currently only for makeup volume
    */
    namespace AutoParameter
    {   
        namespace Modes
        {
            let Volume_OnepoleC_Lan = 0;
            let NumModes = 1;
        }

        namespace M (int mode)
        {
            static_assert ((mode > -1) && (mode < Modes::NumModes), "AutoParameter [[Parameter Processors]]");

            let MaxParameter = (mode == Modes::Volume_OnepoleC_Lan ? 0.f : 0.f);
            let MinParameter = (mode == Modes::Volume_OnepoleC_Lan ? -6.1f : -6.1f);
            let iParameter = (mode == Modes::Volume_OnepoleC_Lan ? MinParameter : MinParameter);
            let Step = (mode == Modes::Volume_OnepoleC_Lan ? 0.1f : 0.1f);
            let MinManualParameter = (mode == Modes::Volume_OnepoleC_Lan ? MinParameter + Step : MinParameter + Step);
            let PtsSize = (mode == Modes::Volume_OnepoleC_Lan ? 4 : 1);
            let Pts = (mode == Modes::Volume_OnepoleC_Lan ? float[PtsSize] (-0.f, -1.f, -2.f, -3.5f) : float[PtsSize] (0));

            float update (float parameter, float control)
            {
                if (parameter < MinManualParameter)
                {
                    if const (mode == Modes::Volume_OnepoleC_Lan)
                        return Pts.readLinearInterpolated (min (control * 0.1f, 3.f));
                }
                else
                    return parameter; 
            }
        }

        processor Processor (int mode)
        {
            output event float out;

            input event float parameterIn [[name: "Volume", min: M (mode)::MinParameter, max: M(mode)::MaxParameter, init: M(mode)::iParameter, step: M(mode)::Step, unit: "dB"]];
            input event float controlIn;

            event parameterIn (float v) { parameter = v; recalc = true; }
            event controlIn (float v) { control = v; recalc = true; }

            float parameter = M(mode)::iParameter;
            float control;
            bool recalc = true;

            void run() 
            { 
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        out << M(mode)::update (parameter, control);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        advance();
                    }
                }
            }
        }
    }

    /** Map float event(s) to smoothed SampleType stream(s); heavily modified version of soul::gain::SmoothedGainParameter

        Note:
        - float event(s) are smoothed s.t. their maximum sine modulation frequency that preserves their amplitude is 50 Hz
        - iParameter is a float[] that defines the initial value of the parameter(s) corresponding to each of the float event(s)
        - This Processor may be modified in the future to include other one-to-one, one-to-two, two-to-one, or two-to-two event-stream mapping Modes
    */       
    namespace SmoothedParameter
    {
        //Only gains and gain-related metrics need smoothed. TPT filters intrinsically smooth their cutoff gains.
        let DOUBLE_SLEW_RATE_SECONDS_GAIN = 100.0; //1 unit unipolar sine period is approx 2 units of movement (i.e. the sine modulates b/w 0 and 1); 100/2 = 50 Hz 
        let DOUBLE_SLEW_RATE_SECONDS_DECIBEL = 5000.0; //1 unit unipolar sine period is approx 100dBs of movement; 5000/100 = 50 Hz  
        let DOUBLE_SLEW_RATE_SECONDS_RATIO = 100.0; //1 unit unipolar sine period is approx 20 units of movement; 1000/20 = 50 Hz

        namespace ModeIdx
        {
            let GainToGain = 0;
            let DecibelToGain = 1;
            let MixPanToGains = 2;
            let PercentToGain = 3;
            let DecibelToDecibel = 4;
            let RatioToRatio = 5;
            let MakeupMixPansToGains = 6;
            let DecibelToGainAndReciprocal = 7;
            let NumIdxs = 8;
        }

        namespace Func
        {
            let Identity = 0;
            let DecibelToGain = 1; 
            let MixPanToGains = 2;
            let PercentToGain = 3;
            let MakeupMixPansToGains = 4;
            let LinearToLog = 5;
            let LogToLinear = 6;
            let DecibelToGainAndReciprocal = 7;
        }   

        struct Mode
        {
            int idx, numIn, numOut, funcD, funcE;
            float64 slewRateSeconds;
        }
        
        let Modes = Mode[ModeIdx::NumIdxs] (
            Mode (ModeIdx::GainToGain, 1, 1, Func::Identity, Func::Identity, DOUBLE_SLEW_RATE_SECONDS_GAIN),
            Mode (ModeIdx::DecibelToGain, 1, 1, Func::DecibelToGain, Func::Identity, DOUBLE_SLEW_RATE_SECONDS_GAIN),
            Mode (ModeIdx::MixPanToGains, 2, 2, Func::MixPanToGains, Func::Identity, DOUBLE_SLEW_RATE_SECONDS_GAIN),
            Mode (ModeIdx::PercentToGain, 1, 1, Func::PercentToGain, Func::Identity, DOUBLE_SLEW_RATE_SECONDS_GAIN),
            Mode (ModeIdx::DecibelToDecibel, 1, 1, Func::Identity, Func::Identity, DOUBLE_SLEW_RATE_SECONDS_DECIBEL),
            Mode (ModeIdx::RatioToRatio, 1, 1, Func::LinearToLog, Func::LogToLinear, DOUBLE_SLEW_RATE_SECONDS_RATIO),
            Mode (ModeIdx::MakeupMixPansToGains, 4, 2, Func::MakeupMixPansToGains, Func::Identity, DOUBLE_SLEW_RATE_SECONDS_GAIN),
            Mode (ModeIdx::DecibelToGainAndReciprocal, 1, 2, Func::DecibelToGainAndReciprocal, Func::Identity, DOUBLE_SLEW_RATE_SECONDS_GAIN)
        );

        let MAX_NUM_IN = 4;
        let MAX_NUM_OUT = 2;

        using ParameterType = float[MAX_NUM_IN];

        struct Coeffs
        {
            SampleType[MAX_NUM_OUT] target;
            SampleType[MAX_NUM_OUT] increment;
        }

        struct State
        {
            SampleType[MAX_NUM_OUT] current;
            int remainingSamples;
        }

        SampleType[MAX_NUM_OUT] decodeParameter (ParameterType parameter, int modeIdx)
        {
            let mode = Modes.at(modeIdx);

            SampleType[MAX_NUM_OUT] y;

            if (mode.funcD == Func::Identity)
                y.at(0) = SampleType (parameter.at(0));
            else if (mode.funcD ==  Func::DecibelToGain)
                y.at(0) = vdBtoGain (SampleType (parameter.at(0)));
            else if (mode.funcD == Func::MixPanToGains)
            {
                let y2 = vMixPanToGains (parameter.at(0), parameter.at(1));

                for (int i = 0; i < y2.size; ++i)
                    y.at(i) = y2.at(i);
            }
            else if (mode.funcD == Func::PercentToGain)
                y.at(0) = parameter.at(0) * 0.01;
            else if (mode.funcD == Func::LinearToLog)
                y.at(0) = log10 (parameter.at(0));
            else if (mode.funcD == Func::MakeupMixPansToGains)
            {
                let y2 = vMakeupMixPansToGains (parameter.at(0), parameter.at(1), parameter.at(2), parameter.at(3));
                
                for (int i = 0; i < y2.size; ++i)
                    y.at(i) = y2.at(i);
            }
            else // if (mode.funcD == Func::DecibelToGainAndReciprocal)
            {
                SampleType[2] y2;

                y2.at(0) = vdBtoGain (SampleType (parameter.at(0)));
                y2.at(1) = ONE / y2.at(0);
                
                for (int i = 0; i < y2.size; ++i)
                    y.at(i) = y2.at(i);
            }

            return y;
        }

        SampleType[MAX_NUM_OUT] encodeParameter (SampleType[MAX_NUM_OUT] parameter, int modeIdx)
        {
            let mode = Modes.at(modeIdx);

            SampleType[MAX_NUM_OUT] y;

            if (mode.funcE == Func::LogToLinear)
            {
                y.at(0) = vpow (SampleType (10.0), parameter.at(0));
            }
            else
                return parameter;

            return y;
        }

        void update (Coeffs& c, ParameterType parameter, State& s, int modeIdx, float64 fs)
        {
            let mode = Modes.at(modeIdx);
            let divMaxDelta = fs / mode.slewRateSeconds;

            c.target = decodeParameter (parameter, modeIdx);

            for (int i = 0; i < mode.numOut; ++i)
                s.remainingSamples = max (s.remainingSamples, int (vmaxr (vabs (c.target.at(i) - s.current.at(i)) * divMaxDelta)));
            s.remainingSamples = max (1, s.remainingSamples);

            for (int i = 0; i < mode.numOut; ++i)
                c.increment.at(i) = (c.target.at(i) - s.current.at(i)) / SampleType (s.remainingSamples);
        }

        void updateUnsmoothed (Coeffs& c, ParameterType parameter, State& s, int modeIdx)
        {
            c.target = decodeParameter (parameter, modeIdx);

            s.remainingSamples = 1;
        }

        SampleType[MAX_NUM_OUT] process (State& s, const Coeffs& c)
        {
            if (s.remainingSamples != 0)
            {
                if (--(s.remainingSamples) == 0)
                    for (int i = 0; i < s.current.size; ++i)
                        s.current.at(i) = c.target.at(i);
                else
                    for (int i = 0; i < s.current.size; ++i)
                        s.current.at(i) += c.increment.at(i);
            }


            return s.current;
        }

        processor Processor (ParameterType iParameter, int modeIdx)
        {
            output stream SampleType out, out1;
            input event float in, in1, in2, in3;

            event in (float v) { parameter.at(0) = v; recalc = true; }
            event in1 (float v) { parameter.at(1) = v; recalc = true; }
            event in2 (float v) { parameter.at(2) = v; recalc = true; }
            event in3 (float v) { parameter.at(3) = v; recalc = true; }

            float[MAX_NUM_IN] parameter;
            bool recalc = false;

            void init()
            {
                for (int i = 0; i < iParameter.size; ++i)
                    parameter.at(i) = iParameter.at(i);
            }

            void run()
            {   
                State s;
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                c.updateUnsmoothed (parameter, s, modeIdx);
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (parameter, s, modeIdx, processor.frequency);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        let y = s.process (c);

                        out << y.at(0);
                        out1 << y.at(1);

                        advance();
                    }
                }
            }
        }
    }

    /** Map a float event directly to a SampleType stream */
    namespace UnsmoothedParameter
    {     
        namespace ModeIdx
        {
            let TauToOmega = 0;
            let Identity = 1;
            let PhaseInverts = 2;
            let PhaseInvert = 3;
            let NumIdxs = 4;
        }

        let MAX_NUM_IN = 2;
        using ParameterType = float[MAX_NUM_IN];

        namespace M (int modeIdx)
        {
            SampleType decodeParameter (ParameterType parameter) //do this per sample
            {
                if const (modeIdx == ModeIdx::TauToOmega)
                    return vTauToOmega (parameter.at(0));
                else if const (modeIdx == ModeIdx::Identity)
                    return SampleType (parameter.at(0));
                else if const (modeIdx == ModeIdx::PhaseInverts)
                    return vPhaseInvertsToGain (parameter.at(0), parameter.at(1)); 
                else //if const (modeIdx == ModeIdx::PhaseInvert)
                    return vPhaseInvertToGain (parameter.at(0));
            }
        }

        processor Processor (ParameterType iParameter, int modeIdx)
        {              
            output stream SampleType out;
            input event float in, in1;

            event in (float v) { parameter.at(0) = v; recalc = true; }
            event in1 (float v) { parameter.at(1) = v; recalc = true; }

            float[MAX_NUM_IN] parameter;
            bool recalc = true;

            SampleType y;

            void init()
            {
                for (int i = 0; i < iParameter.size; ++i)
                    parameter.at(i) = iParameter.at(i);
            }

            void run()
            {   
                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        y = M(modeIdx)::decodeParameter (parameter);
                    }
                    
                    out << y;

                    advance();
                }
            }
        }
    }

    /** Map a compile-time constant float  to a SampleType stream */
    namespace ConstantParameter
    {
        processor Processor (float iConstant)
        {
            output stream SampleType out;

            let constant = SampleType (iConstant);

            void run()
            {
                loop
                {
                    out << constant;

                    advance();
                }
            }
        }
    }

/*==============================================================================
Vectorized Helper Functions                                             02/24/22
==============================================================================*/

    /** The unit step function */
    SampleType vStep (SampleType x)
    {
        return viflt (ZERO, ONE, x, ZERO);
    }

    /** 'vCTF' with additional color settings to shape the knee 
    
        Parameters:
        - ratio0: ratio above threshold (> 1 is downward compression, < 1 is upward expansion)
        - ratio1: ratio below threshold (> 1 is upward compression, < 1 is downward expansion)
        - height: color height in dB
        - width: color width in dB (internally limited to [3, inf))
        - softness: width of the quadratic interpolation in dB

        Notes:
        - gain is limited to (0, 1.9] (BIBO stable)
        - At extremely high height parameters, the CTF becomes a 'swell' function
        - Algebraic bell-shaped function (derivative of a sigmoidal function arctan) used for color;
          This is cheap to compute and modulation stable
        - Soft knee is quadratic interpolation given y and dy/dx at xdB = T + softness/2 and T - softness/2 
        - See https://blog.audio-tk.com/2015/09/08/audio-toolkit-additional-gain-functions/
        - See https://people.math.sc.edu/kellerlv/Quadratic_Interpolation.pdf
    */
    SampleType vCTF_Color (SampleType x, SampleType threshold, SampleType ratio0, SampleType ratio1, SampleType softness, SampleType color)
    {
        //dB scale
        let xdB = vGainTodB (x);
        let xdBmthr = xdB - threshold;

        //constants
        let divRatio0 = ONE/ratio0;
        let divRatio1 = ONE/ratio1;
        let softnessDiv2 = softness * HALF;
        let thresholdPlus = threshold + softnessDiv2;

        //softness
        let c = (divRatio0 - divRatio1) / vmax (softness * TWO, DIV_TOL);
        let b = divRatio0 - TWO * c * thresholdPlus;
        let a = threshold - threshold * divRatio0 + c * vpow (thresholdPlus, 2);
        let softKnee = a  + b * xdB + c * vpow (xdB, 2);

        //color
        let divColorWidth = ONE / vmax (vabs (color), ONE);
        let colorInternal = color / (ONE + vpow (xdBmthr * divColorWidth, 2));

        //CTF
        let ydB = viflt ( 
            threshold + xdBmthr * divRatio1, 
            viflt (
                softKnee,
                threshold + xdBmthr * divRatio0, 
                xdBmthr,
                softnessDiv2
            ),
            xdBmthr, 
            -softnessDiv2
        ) + colorInternal;
        
        //convert to linear gain
        let y = vmin (vdBtoGain (ydB) / x, MAX_EFFECT_GAIN);
        
        return viflt (ONE, y, x, NOISE_FLOOR);
    }

    /** Classical compressor transfer function (CTF) that can become 2 compression and 2 expansion transfer functions 
    
        Parameters:
        - ratio0: ratio above threshold (> 1 is downward compression, < 1 is upward expansion)
        - ratio1: ratio below threshold (> 1 is upward compression, < 1 is downward expansion)

        Notes:
        - See https://www.dropbox.com/s/cjq4t08u6pqkaas/ADC17FiftyShadesDistortion.zip?dl=0&file_subpath=%2FCode%2FDynamicsCompressor.cpp
    */
    SampleType vCTF (SampleType x, SampleType threshold, SampleType ratio0, SampleType ratio1)
    {
        let divRatio0m1 = ONE/ratio0 - ONE;
        let divRatio1m1 = ONE/ratio1 - ONE;

        let thrlin = vdBtoGain (threshold);

        let yInternal = viflt (vpow (x * (ONE/thrlin), divRatio1m1), vpow (x * (ONE/thrlin), divRatio0m1), x, thrlin);

        let y = vmin (yInternal, MAX_EFFECT_GAIN);

        return viflt (ONE, y, x, NOISE_FLOOR);
    }

    /** Bucket Brigade Device static nonlinear mapping
    
        Notes:
        - Use for low order, monotonically decreasing harmonics
        - Needs makeup gain at high settings, NOT always BIBO stable
        - Harmonics boosted compared to the original version according to the linear gain b
        - See: http://dafx10.iem.at/proceedings/papers/RaffelSmith_DAFx10_P42.pdf  
    */
    SampleType vBBD (SampleType x, SampleType b)
    {
        let c1 = b * SampleType (1.0/8.0);
        let c2 = b* SampleType (1.0/16.0);

        return x - c1 * vpow (x, 2) - c2 * vpow (x, 3); 
    }

    /** Omega (rad/s) modulation simulating anhysteretic nonlinear inductance/capacitance
    
        Parameters:
        - x: sidechain signal
        - N: nonlinearity

        Notes:
        - The reciprocal of a algebraic sigmoid of class C1
        - See: https://en.wikipedia.org/wiki/Differentiable_function#Differentiability_classes
        - The linear cutoff is 1. Add a bias if a different linear cutoff is desired
        (i.e. vLan (x, N) + bias)
    */
    SampleType vLan (SampleType x, SampleType N)
    {
        return vpow (N * vabs (x) + ONE, 2);
    }

    SampleType vStereoLink (SampleType x, float percent)
    {
        let b = vMixToGains (percent * 0.5f);
        let x1 = SampleType (x[1] , x[0]);

        return b.at(0) * x + b.at(1) * x1;
    }

    /** An algebraic sigmoid function of class C2

        f(x) = x / sqrt (x^2 + 1) 

        Notes:
        - A cheap 'tanh' approximation
        - See: https://en.wikipedia.org/wiki/Differentiable_function#Differentiability_classes
    */
    SampleType vSigmoidC2 (SampleType x)
    {
        return x / sqrt (x * x + ONE);
    }

    /** Convert cutoff (Hz) to the cutoff gain of a TPT Onepole filter 
    
        Notes:
        - Optimized for 'update'
        - Prewarped
    */
    SampleType vCutoffToG_Onepole (float x, float64 fs)
    {
        let Tpi = SampleType (pi / fs);
        
        let gOnepole = tanh (SampleType (x) * Tpi);

        return gOnepole / (ONE + gOnepole);
    }

    /** Convert tau (ms) to Omega, the analog angular cutoff frequency
    
        Notes:
        - Optimized for 'update'
    */
    SampleType vTauToOmega (float x)
    {
        return SampleType(1000.f / x);
    }

    /** vOmegaToG_Onepole without prewarping
    
        Notes:
        - Optimized for per-sample calculations
        - Use with 2x oversampling if using for frequency effects
    */
    SampleType vOmegaToG_OnepoleUnwarped (SampleType x, float64 fs)
    {
        let Tdiv2 = SampleType (1.0 / (2.0 * fs));

        let gOnepole = x * Tdiv2;

        return gOnepole / (ONE + gOnepole);
    }

    /** Convert Omega (rad/s) to the cutoff gain of a TPT Onepole filter */
    SampleType vOmegaToG_Onepole (SampleType x, float64 fs)
    {
        let Tdiv2 = SampleType (1.0 / (2.0 * fs));

        let gOnepole = tan (x * Tdiv2);

        return gOnepole / (ONE + gOnepole);
    }

    /** Convert gain to decibels and limit to >= -100.0 dB */
    SampleType vGainTodB (SampleType x)
    {
        let b = vmax (NOISE_FLOOR, x);

        return SampleType (20.0) * log10 (b);
    }

    /** Convert decibels to gain and limit inputs to >= -100.0 dB */
    SampleType vdBtoGain (SampleType x)
    {
        let b = vpow (SampleType (10.0), x * SampleType (1.0 / 20.0)); 

        return vmax (NOISE_FLOOR, b);
    }

    /** Return 1 if x is positive, -1 if negative otherwise */
    SampleType vSgn (SampleType x)
    {
        return SampleType (x[0] > 0 ? 1 : -1, x[1] > 0 ? 1 : -1);
    }

    SampleType vPhaseInvertsToGain (float invertL, float invertR)
    {
        return SampleType (bool (invertL) ? -1.0 : 1.0, bool (invertR) ? -1.0 : 1.0);
    }

    SampleType vPhaseInvertToGain (float invert)
    {
        return (bool (invert) ? -ONE : ONE);
    }

    /** Convert makeup volume, mix, and pan values to a gain for applying to dry and wet SampleType streams (indicies 0 and 1 respectively) */
    SampleType[2] vMakeupMixPansToGains (float makeup, float mix, float panDry, float panWet)
    {
        let bMakeup = SampleType[2] (ONE, vdBtoGain(makeup));
        let bMix = vMixToGains (mix);
        let bPans = SampleType[2](vPanToGain (panDry), vPanToGain(panWet));

        return SampleType[2] (bMakeup.at(0) * bMix.at(0) *  bPans.at(0), bMakeup.at(1) * bMix.at(1) *  bPans.at(1));
    }

    /** Convert a mix and a pan to a SampleType[2] gain array
    
        Use case: mix and pan 2 SampleType streams simultaneously
    */
    SampleType[2] vMixPanToGains (float m, float p)
    {
        let bPan = vPanToGains (p);
        let bMix = vMixToGains (m);

        return SampleType[2] (bMix.at(0) * bPan.at(0), bMix.at(1) * bPan.at(1));
    }

    /** Convert a mix value in range [0, 100] to a SampleType[2] gain array
    
        Use case: mix 2 SampleType streams
    */
    SampleType[2] vMixToGains (float x)
    {
        let b1 = SampleType (x) * SampleType (1.0/100.0);

        return SampleType[2] (ONE - b1, b1);
    }
    
    /** Convert a pan value in range [-1, 1] to a SampleType[2] gain array
    
        Use case: pan 2 SampleType streams simultaneously
    */
    SampleType[2] vPanToGains (float x)
    {
        let b1 = vPanToGain(x);

        return SampleType[2] (TWO - b1, b1);
    }

    /** Convert a linear pan value in range [-1, 1] to a SampleType gain 

        Use case: pan 1 SampleType stream
    */
    SampleType vPanToGain (float x)
    {
        let bR = float64 (x) + 1.0;

        return SampleType (2.0 - bR, bR);
    }

/*==============================================================================
Vectorized Intrinsic Functions                                          03/10/22
==============================================================================*/

    SampleType vabs (SampleType x)
    {
        return SampleType (abs (x[0]), abs (x[1]));
    }

    SampleType vmax (SampleType x, SampleType x1)
    {
        return SampleType (max (x[0], x1[0]), max (x[1], x1[1]));
    }

    SampleType vmin (SampleType x, SampleType x1)
    {
        return SampleType (min (x[0], x1[0]), min (x[1], x1[1]));
    }

    /** Vector reduce max */
    SampleType.elementType vmaxr (SampleType x)
    {
        return max (x[0], x[1]);
    }

    /** Vector reduce min */
    SampleType.elementType vminr (SampleType x)
    {
        return min (x[0], x[1]);
    }

    /** 'pow' for int and SampleType exponents 
    
        T:
        - SampleType: vectorized version of 'pow'
        - int: repeated multiplicaton
    */
    SampleType vpow<T> (SampleType base, T exponent)
    {
        if const (T.isInt)
        {
            var y = base;

            for (int i = 1; i < exponent; ++i)
                y *= base;

            return y;
        }
        else
            return SampleType (pow (base[0], exponent[0]), pow (base[1], exponent[1]));
    }

    /** a < b ? trueStatement : falseStatement */
    SampleType viflt (SampleType trueStatement, SampleType falseStatement, SampleType a, SampleType b)
    {
        return SampleType (a[0] < b[0] ? trueStatement [0] : falseStatement [0], a[1] < b[1] ? trueStatement [1] : falseStatement [1]);
    }

/*==============================================================================
Constants                                                               03/06/22
==============================================================================*/

    //soul::filters
    using SampleType = float64<2>;
    let updateInterval = 256;
    namespace filt = soul::filters (SampleType, SampleType.elementType, updateInterval);
    
    //const SampleType
    let ZERO = SampleType (0.0);
    let HALF = SampleType (0.5);
    let ONE = SampleType (1.0);
    let TWO = SampleType (2.0);
    
    let MAX_EFFECT_GAIN = SampleType (1.5); // about +3.52 dB

    let NOISE_FLOOR = SampleType (0.00001); // -100 dB

    let CHANNEL_ZERO_MASK = SampleType (1.0, 0.0);
    let CHANNEL_ONE_MASK = SampleType (0.0, 1.0);
    
    let DIV_TOL = SampleType (0.0000001); // do not allow division by a number smaller than this

    //const float
    let FLOAT_DIV_SQRT_TWO = 1.f / sqrt (2.f); // Butterworth Q and resonance value for svf
    let FLOAT_MIN_TAU_MS = 1.f / (40.f * float (pi)); // tau in ms which corresponds to a 20kHz cutoff

    //const int
    let INT_MAX_BUFFER_SIZE = 48000; // for arrays of SampleType, 1 second of samples at 48 kHz sample rate
    let INT_MAX_BUFFER_SIZE_MS = 999; // INT_MAX_BUFFER_SIZE minus 1 ms

} //namespace VA


/** Very unstable and random snippets */
namespace VA::Experimental
{
    /** vSigmoidC2 with a gain of 1 at the origin and drive (linear gain) of b
    
        Notes:
        - Use for state saturation with odd order harmonics
        - Requires makeup gain for most values of b
    */
    // SampleType vSigmoidC2S (SampleType x, SampleType b) 
    // {
    //     return vSigmoidC2 (b * x) * (ONE / b); 
    // }

    /** soul::tpt::svf modified for cutoff/resonance modulation via input streams
    
        2x oversampling recommended
    */  
    namespace SvfCR
    {
        struct Coeffs
        {
            SampleType a0;
            SampleType a;
            SampleType p;
        }

        struct State
        {
            SampleType[2] z;
        }

        SampleType[3] process (State& s, SampleType x, const Coeffs& c)
        {
            let hpf = c.a0 * (x - c.p * s.z[0] - s.z[1]);
            let bpf = c.a * hpf + s.z[0];
            let lpf = c.a * bpf + s.z[1];

            s.z[0] = c.a * hpf + bpf;
            s.z[1] = c.a * bpf + lpf;

            return SampleType[3] (lpf, hpf, bpf);
        }

        processor Processor()
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0
            input stream SampleType R; //resonance; must be > 0
            output stream SampleType lowpassOut, highpassOut, bandpassOut;

            void run()
            {
                State s;
                Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5); 

                loop
                {
                    c.a = Omega * Tdiv2; //g
                    c.a0 = ONE / (ONE + TWO * R * c.a + c.a * c.a); //d
                    c.p = TWO * R + c.a; //g1

                    let y = s.process(in, c);

                    lowpassOut  << y[0];
                    highpassOut << y[1];
                    bandpassOut << y[2];
                    
                    advance();
                }
            }
        }
    }
} //namespace VA::Experimental