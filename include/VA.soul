/** GNU GPLv3 License

    Copyright (C) 2021 ZheDeng
    TheZheDeng@gmail.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

/** SOUL-VA (https://github.com/thezhe/SOUL-VA)

    The interface is nearly identical to soul::filters EXCEPT:
    - Effects are 'Processors' under 'VA::HighLevel'
    - Effects have an InType and an OutType which determines channel IO configuration
    - The last 'input event float' is always 'fsIn'. Set this to the current sampling rate.
    - No user-defined types:
        *'SampleType' is float64<2>
        *The internal 'CoeffType' is float64<2>
        *Coefficient 'updateInterval' is every 256 samples at 44.1kHz 
        or scaled as needed (i.e. every 512 samples at 88.2kHz)
        *Each effect's namespace defines an 'InType' and 'OutType' 
    - Parameters not suitable for modulation are commented as 'UNSMOOTHED' in their annotations
    - Expanded set of vector-friendly functions (see 'Vectorized Intrinsic/Helper' sections)
    - Algebraic operations are preferred to avoid expensive transcendentals while providing superior
    accuracy and modulate-ability than look up tables
    See: https://en.wikipedia.org/wiki/Algebraic_function
    - 44.1 and 48kHz are the recommended sampling rates, but rates up through 192kHz are officially supported
    - Each section is marked with a date of last stable update (MM/DD/YYYY)
*/

/** Next version (1.1.0) changelog
    - New Effects: TheExpressor, TheSplit
    - Tests now use Octave via PLUG-QA and support multichannel output
    - .soulpatches now run in multichannel mode when using CLI/Octave 
    - More parameters are now smoothed and modulation stable
    - 44.1/48 internal (works best with ADAA)
*/

/** Task List
    Future Tasks:
    -TheChorus, TheBass, TheSplit update to 192kHz support and Expressor standard
    - TheBass boilerplate, abs before stereo link and rectified lan
    - small dx approximation for hysteretic L  
*/

namespace VA 
{
/*==============================================================================
VA::HighLevel Processors                                                02/12/22
==============================================================================*/

    /** High-level Processors made of components from 'VA' and 'soul' namespaces 
    
        ALL effects can behave nonlinearly and add their own 'virtual analog warmth' 
    */
    namespace HighLevel
    {  
        /** Signal splitter
    
            Use case: Center/Sides (spatial), Crossover (frequency), Loud/Soft (amplitude), Attack/Sustain (time)
        */
        namespace TheSplit
        {
            using InType = SampleType;
            using OutType = SampleType2;

            namespace Modes
            {
                let CenterSides = 0;
                let LowHigh = 1;
                let AttackSustain = 2;
                let LoudSoft = 3;
                let NumModes = 4;
            }

            graph Processor(int iMode = Modes::CenterSides,
                            int iFlip = 0,
                            float iCenterSidesPercent = 100,
                            float iFrequencyHz = 1000,
                            float iAttackMs = 4,
                            float iSustainMs = 30,
                            float iSensitivity_dB = 36,
                            float iStereoLinkAsPercent = 0,
                            float iThreshold_dB = -30,
                            float iReleaseMs = 30,
                            float iStereoLinkLsPercent = 0)
            {
                input stream InType in;
                output stream OutType out;
        
                input
                {
                    event float modeIn [[ name: "Mode", min: 0, max: Modes::NumModes - 1, init: iMode, text: "C&S|L&H|A&S|L&S", group: "GroupSelect" /*UNSMOOTHED*/ ]];
                    event float flipIn [[ name: "Flip", min: 0, max: 1, init: iFlip, text: "Off|On" /*UNSMOOTHED*/ ]];

                    splitCenterSides.centerSidesIn [[ name: "Sides", min: 0, max: 100, init: iCenterSidesPercent, unit: "%", step: 1, group: "C&S" ]];

                    pCrossover.frequencyIn [[ name: "Freq", min: 20, max: 20000, init: iFrequencyHz, step: 1, unit: "Hz", group: "L&H" ]];

                    splitAttackSustain.attackIn [[ name: "Attack", min: 4, max: 26, init: iAttackMs, step: 1, unit: "ms", group: "A&S" ]];
                    splitAttackSustain.sustainIn [[ name: "Sustain", min: 30, max: 200, init: iSustainMs, step: 1, unit: "ms", group: "A&S" ]];
                    splitAttackSustain.sensitivityIn [[ name: "Sens", min: 0, max: 36, init: iSensitivity_dB, step: 1, unit: "dB", group: "A&S" ]];
                    splitAttackSustain.stereoLinkIn stereoLinkAsIn [[ name: "Link", min: 0, max: 100, init: iStereoLinkAsPercent, unit: "%", step: 1, group: "A&S" ]];

                    splitLoudSoft.thresholdIn [[ name: "Thresh", min: -50.f, max: -12.f, init: iThreshold_dB, unit: "dB", step: 1, group: "L&S" ]];
                    splitLoudSoft.releaseIn [[ name: "Release", min: 30, max: 999, init: iReleaseMs, unit: "ms", step: 1, group: "L&S" ]];
                    splitLoudSoft.stereoLinkIn stereoLinkLsIn [[ name: "Link", min: 0, max: 100, init: iStereoLinkLsPercent, unit: "%", step: 1, group: "L&S" ]];
                }
        
                let
                {
                    //non-boilerplate Processors
                    splitCenterSides = SplitCenterSides::Processor (iCenterSidesPercent);
                    pCrossover = filt::tpt::crossover::Processor (iFrequencyHz);
                    splitAttackSustain = SplitAttackSustain::Processor (iAttackMs, iSustainMs, iSensitivity_dB, iStereoLinkAsPercent);
                    splitLoudSoft = SplitLoudSoft::Processor (iThreshold_dB, iReleaseMs, iStereoLinkLsPercent);
                    
                    mux4To1_0 = Mux4To1::Processor (iMode);
                    mux4To1_1 = Mux4To1::Processor (iMode);

                    mux2To1_0 = Mux2To1::Processor (iFlip);
                    mux2To1_1 = Mux2To1::Processor (iFlip);

                    //boilerplate Processors
                    dcBlockerIn = filt::dc_blocker::Processor (FLOAT_DC_BLOCKER_CUTOFF_HZ);
                    dcBlockerOut0 = filt::dc_blocker::Processor (FLOAT_DC_BLOCKER_CUTOFF_HZ);
                    dcBlockerOut1 = filt::dc_blocker::Processor (FLOAT_DC_BLOCKER_CUTOFF_HZ);
                    sampleTypesToSampleType2 = SampleTypesToSampleType2::Processor;
                }
        
                connection
                {
                    modeIn -> mux4To1_0.idxIn, mux4To1_1.idxIn;
                    flipIn -> mux2To1_0.idxIn, mux2To1_1.idxIn;

                    in -> dcBlockerIn -> splitCenterSides.in, pCrossover.in, splitLoudSoft.in, splitAttackSustain.in;

                    splitCenterSides.centerOut -> mux4To1_0.in0;
                    splitCenterSides.sidesOut -> mux4To1_1.in0;

                    pCrossover.lowOut -> mux4To1_0.in1;
                    pCrossover.highOut -> mux4To1_1.in1;
                    
                    splitAttackSustain.attackOut -> mux4To1_0.in2;
                    splitAttackSustain.sustainOut -> mux4To1_1.in2;

                    splitLoudSoft.loudOut -> mux4To1_0.in3;
                    splitLoudSoft.softOut -> mux4To1_1.in3;

                    mux4To1_0.out -> mux2To1_0.in0, mux2To1_1.in1;
                    mux4To1_1.out -> mux2To1_0.in1, mux2To1_1.in0;

                    mux2To1_0.out -> dcBlockerOut0 -> sampleTypesToSampleType2.in0;
                    mux2To1_1.out -> dcBlockerOut1 -> sampleTypesToSampleType2.in1;

                    sampleTypesToSampleType2.out -> out;
                }
            }
        }

        /** Upwards/Downwards Ex(pander)/(com)pressor with a colored knee

            Notes:
            - Use case: limiter, attack/release emphasis/de-emphasis, general dynamics processor, parallel/ny compression
            - Max effect gain is 1.9 or about +5.58 dB
        */
        namespace TheExpressor
        {
            using InType = SampleType2;
            using OutType = SampleType;

            namespace Modes
            {
                let SidechainOff = 0;
                let SidechainOn = 1;
            }
            
            graph Processor(int iMode = Modes::SidechainOff,
                            float iAttackMs = 1,
                            float iReleaseMs = 30, 
                            float iStereoLinkPercent = 0,
                            float iThreshold_dB = -50,
                            float iRatio0 = 20,
                            float iRatio1 = 1,
                            float iSoftness_dB = 10,
                            float iColor_dB = 24,
                            float iHpfCutoffHz = 1,
                            float iMakeup_dB = 0,
                            float iMixPercent = 100,
                            float iFs = 0)
            {
                input stream InType in;
                output stream OutType out;

               // output stream SampleType grOut;
        
                input
                {
                    event float sidechainIn [[ name: "SC", min: 0, max: 1, init: iMode, text:"Off|On" /*UNSMOOTHED*/ ]];   
                    event float attackIn [[ name: "Attack", min: 1, max: 50, init: iAttackMs, unit: "ms", step: 0.1 ]];
                    event float releaseIn [[ name: "Release", min: 30, max: 3000, init: iReleaseMs, unit: "ms", step: 1 ]];
                    event float stereoLinkIn [[ name: "Link", min: 0, max: 100, init: iStereoLinkPercent, unit: "%", step: 1 ]];
                    event float thresholdIn [[ name: "Thresh", min: -50.f, max: 0.f, init: iThreshold_dB, unit: "dB", step: 0.1f]];
                    event float ratio0In [[ name: "Ratio (> Thr)", min: 0.5f, max: 20.f, init: iRatio0, step: 0.1f ]];
                    event float ratio1In [[ name: "Ratio (< Thr)", min: 0.5f, max: 1.5f, init: iRatio1, step: 0.1f ]];
                    event float softnessIn [[ name: "Softness", min: 0, max: 10, init: iSoftness_dB, unit: "dB", step: 0.1f ]];
                    event float colorIn [[ name: "Color", min: -24, max: 24, init: iColor_dB, unit: "dB", step: 0.1f ]]; 
                    event float cutoffIn [[ name: "Detector HP", min: 1, max: 500, init: iHpfCutoffHz, unit: "Hz"]];
                    event float makeupIn [[ name: "Makeup", min: -6, max: 50, init: iMakeup_dB, step: 0.1f, unit: "dB" ]];
                    event float mixIn [[ name: "Mix", min: 0, max: 100, init: iMixPercent, unit: "%", step: 1 ]];

                    mux3To1.idxIn fsIn [[ name: "fs", min: 0, max: 2, init: iFs, step: 1, text: "44.1/48|88.2/96|176.4/192" /*UNSMOOTHED*/ ]];
                }
        
                let
                {
                    internalDS0 = Internal::Processor (iMode, iAttackMs, iReleaseMs, iStereoLinkPercent, iThreshold_dB, iRatio0, iRatio1, iSoftness_dB, iColor_dB, iHpfCutoffHz, iMakeup_dB, iMixPercent);
                    internalDS2 = Internal::Processor (iMode, iAttackMs, iReleaseMs, iStereoLinkPercent, iThreshold_dB, iRatio0, iRatio1, iSoftness_dB, iColor_dB, iHpfCutoffHz, iMakeup_dB, iMixPercent) / 2;
                    internalDS4 = Internal::Processor (iMode, iAttackMs, iReleaseMs, iStereoLinkPercent, iThreshold_dB, iRatio0, iRatio1, iSoftness_dB, iColor_dB, iHpfCutoffHz, iMakeup_dB, iMixPercent) / 4;

                    mux3To1 = Mux3To1::Processor(iFs);
                }
        
                connection
                {
                    //input event float
                    sidechainIn -> internalDS0.sidechainIn, internalDS2.sidechainIn, internalDS4.sidechainIn;
                    attackIn -> internalDS0.attackIn, internalDS2.attackIn, internalDS4.attackIn;   
                    releaseIn -> internalDS0.releaseIn, internalDS2.releaseIn, internalDS4.releaseIn;
                    stereoLinkIn -> internalDS0.stereoLinkIn, internalDS2.stereoLinkIn, internalDS4.stereoLinkIn;
                    thresholdIn -> internalDS0.thresholdIn, internalDS2.thresholdIn, internalDS4.thresholdIn;
                    ratio0In -> internalDS0.ratio0In, internalDS2.ratio0In, internalDS4.ratio0In;
                    ratio1In -> internalDS0.ratio1In, internalDS2.ratio1In, internalDS4.ratio1In;
                    softnessIn -> internalDS0.softnessIn, internalDS2.softnessIn, internalDS4.softnessIn;
                    colorIn -> internalDS0.colorIn, internalDS2.colorIn, internalDS4.colorIn;
                    cutoffIn -> internalDS0.cutoffIn, internalDS2.cutoffIn, internalDS4.cutoffIn;
                    makeupIn -> internalDS0.makeupIn, internalDS2.makeupIn, internalDS4.makeupIn;
                    mixIn -> internalDS0.mixIn, internalDS2.mixIn, internalDS4.mixIn;

                    //apply 3 downsampling rates
                    [sinc] in -> internalDS0.in, internalDS2.in, internalDS4.in;
                    [sinc] internalDS0.out -> mux3To1.in0;
                    [sinc] internalDS2.out -> mux3To1.in1;
                    [sinc] internalDS4.out -> mux3To1.in2;
                    mux3To1.out -> out;
                }
            }
            
            namespace Internal
            {
                graph Processor(int iMode,
                                float iAttackMs,
                                float iReleaseMs, 
                                float iStereoLinkPercent,
                                float iThreshold_dB,
                                float iRatio0,
                                float iRatio1,
                                float iSoftness_dB,
                                float iColor_dB,
                                float iHpfCutoffHz,
                                float iMakeup_dB,
                                float iMixPercent)
                {
                    input stream InType in;
                    output stream OutType out;

                    input
                    {
                        mux2To1.idxIn sidechainIn [[ name: "SC", min: 0, max: 1, init: iMode, text:"Off|On" /*UNSMOOTHED*/ ]];   

                        ballisticsFilter.attackIn;
                        ballisticsFilter.releaseIn;

                        stereoLink.stereoLinkIn;

                        ctfColor.thresholdIn;
                        ctfColor.ratio0In;
                        ctfColor.ratio1In;
                        ctfColor.softnessIn;
                        ctfColor.colorIn;

                        pSvf.frequencyIn cutoffIn [[ name: "Detector HP", min: 1, max: 500, init: iHpfCutoffHz, unit: "Hz"]];
                    
                        smoothedVolume.volumeIn makeupIn [[ name: "Makeup", min: -6, max: 50, init: iMakeup_dB, step: 0.1f, unit: "dB" ]];
                        smoothedMixPan.mixIn;
                    }

                    let
                    {
                        //non-boilerplate Processors
                        sampleType2ToSampleTypes = SampleType2ToSampleTypes::Processor;
                        mux2To1 = Mux2To1::Processor (iMode);
                        
                        pSvf = filt::tpt::svf::Processor (iHpfCutoffHz, FLOAT_DIV_SQRT_TWO);

                        absADAA = AbsADAA::Processor;     

                        ballisticsFilter = BallisticsFilter::Processor (iAttackMs, iReleaseMs);
                        stereoLink = StereoLink::Processor (iStereoLinkPercent);
                        ctfColor = CTF_Color::Processor (iThreshold_dB, iRatio0, iRatio1, iSoftness_dB, iColor_dB);

                        applyGain = ApplyGain::Processor;

                        //boilerplate Processors
                        ultraBlockerIn0 = UltraBlocker::Processor;
                        ultraBlockerIn1 = UltraBlocker::Processor;
                        dcBlockerIn = filt::dc_blocker::Processor (FLOAT_DC_BLOCKER_CUTOFF_HZ);
                        dcBlockerOut = filt::dc_blocker::Processor (FLOAT_DC_BLOCKER_CUTOFF_HZ);

                        smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, 0);
                        smoothedVolume = SmoothedVolume::Processor (iMakeup_dB);
                    }

                    connection
                    {
                        in -> sampleType2ToSampleTypes.in;

                        sampleType2ToSampleTypes.out0 -> dcBlockerIn -> ultraBlockerIn0 -> smoothedMixPan.in0, applyGain.in;

                        sampleType2ToSampleTypes.out0 -> mux2To1.in0;
                        sampleType2ToSampleTypes.out1 -> mux2To1.in1;
                        mux2To1.out -> ultraBlockerIn1 -> pSvf.in; 
                        pSvf.highpassOut -> absADAA -> stereoLink.in;
                        stereoLink.out -> ballisticsFilter.in;
                        ballisticsFilter.out -> ctfColor.in;
                        ctfColor.out -> applyGain.b;

                        applyGain.out -> smoothedVolume.in;
                        smoothedVolume.out -> smoothedMixPan.in1;
                        smoothedMixPan.out -> dcBlockerOut -> out;                    
                    }
                }
            }
        }

        /** Modulated 'DelayLine' with 'LadderLpfS' attached to its output
        
            Notes:
            - Use case: chorus, slow flange, doubler, stereo widener
            - Loosely based on Boss CE-3 Chorus Pedal
        */
        namespace TheChorus
        {
            using InType = SampleType;
            using OutType = SampleType;

            graph Processor (float iDepthPercent = 50,
                            float iRateHz = 2.f,
                            float iWidthDeg = 180,
                            int iMode = Lfo::Modes::Triangle,
                            float iDelayMs = 3,
                            float iNonlinearity = 0.5f,
                            float iResonance = 1,
                            float iCutoffHz = 3000,
                            float iMixPercent = 50,
                            float iPan = 0,
                            float iMakeup_dB = 0)
            {
                input stream InType in;
                output stream OutType out;
        
                input
                { 
                    lfo.depthIn [[ name: "Depth", min: 0, max: 100, init: iDepthPercent, unit: "%", step: 1 ]];
                    lfo.rateIn [[ name: "Rate", min: 0.1, max: 4.0, init: iRateHz, unit: "Hz", step: 0.1 ]];
                    lfo.widthIn; //UNSMOOTHED
                    lfo.modeIn; //UNSMOOTHED

                    delayLine.delayIn [[ name: "Delay", min: 0, max: 35, init: iDelayMs, unit: "ms", step: 1 /*UNSMOOTHED*/ ]];

                    ladderLpfS.nonlinearityIn;
                    ladderLpfS.resonanceIn;
                    ladderLpfS.cutoffIn;

                    smoothedMixPan.mixIn;
                    smoothedMixPan.panIn;
                    smoothedVolume.volumeIn makeupIn [[ name: "Makeup", min: -12, max: 12, init: iMakeup_dB, step: 0.1f, unit: "dB" ]];
                }
        
                let
                {
                    //non-boilerplate Processors
                    lfo = Lfo::Processor (iDepthPercent, iRateHz, iWidthDeg, iMode);
                    delayLine = DelayLine::Processor (iDelayMs, 35, 4);

                    ladderLpfS = LadderLpfS::Processor (iCutoffHz, iResonance, iNonlinearity);

                    //boilerplate Processors
                    dcBlockerIn = filt::dc_blocker::Processor (FLOAT_DC_BLOCKER_CUTOFF_HZ);
                    dcBlockerOut = filt::dc_blocker::Processor (FLOAT_DC_BLOCKER_CUTOFF_HZ);

                    smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, iPan);
                    smoothedVolume = SmoothedVolume::Processor (iMakeup_dB);
                }
        
                connection
                {
                    lfo.out -> delayLine.lfoIn;
                    
                    in -> dcBlockerIn -> delayLine.in, smoothedMixPan.in0;
                    
                    delayLine.out -> ladderLpfS.in;
                    ladderLpfS.out -> smoothedMixPan.in1;
                    
                    smoothedMixPan.out -> smoothedVolume.in;
                    smoothedVolume.out -> dcBlockerOut -> out;
                }
            }
        }

        /** 'OnepoleC' in all pass mode modulated by 'LanADAA' 

            Use case: boost and sustain low frequencies
        */
        namespace TheBass
        {
            using InType = SampleType;
            using OutType = SampleType;

            graph Processor (float iNonlinearity = 250, float iStereoLinkPercent = 100)
            {
                input stream InType in;
                output stream OutType out;
        
                input
                {
                    event float nonlinearityIn [[ name: "Nonlin", min: 0, max: 350, init: iNonlinearity, step: 1 /*UNSMOOTHED*/]];
                    stereoLink.stereoLinkIn;
                    autoSmoothedVolume.parameterIn volumeIn;
                    //smoothedMixPan.mixIn;
                    //smoothedMixPan.panIn;
                }
        
                let
                {
                    

                    stereoLink = StereoLink::Processor (iStereoLinkPercent);

                    internal = Internal::Processor (iNonlinearity) * 2;
                    onepoleMixer = OnepoleMixer::Processor (OnepoleMixer::Modes::APF);

                    //boilerplate Processors
                    dcBlockerIn = filt::dc_blocker::Processor (0.1);
                    autoSmoothedVolume = AutoSmoothedVolume::Processor (AutoParameter::Modes::Volume_OnepoleC_Lan);
                   // smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, iPan);
                }
        
                connection
                {
                    nonlinearityIn -> internal.nonlinearityIn;
                    nonlinearityIn -> autoSmoothedVolume.controlIn;

                    in -> dcBlockerIn -> stereoLink.in, internal.in;

                    stereoLink.out -> internal.Lin;

                    internal.highpassOut -> onepoleMixer.highpassIn;
                    internal.lowpassOut -> onepoleMixer.lowpassIn;
                    
                    onepoleMixer.out -> autoSmoothedVolume.in;
                    autoSmoothedVolume.out -> out; 
                }
            }

            namespace Internal 
            {
                graph Processor (float iNonlinearity)
                {
                    input stream SampleType in, Lin;
                    output stream SampleType highpassOut, lowpassOut;
            
                    input
                    {
                        L.nonlinearityIn;
                    }

                    let
                    {
                        L = LanADAA::Processor (iNonlinearity);
                        onepoleC = OnepoleC::Processor;
                    }
            
                    connection
                    {
                        in -> onepoleC.in;

                        Lin -> L.in;
                        L.Omega -> onepoleC.Omega;

                        onepoleC.highpassOut -> highpassOut;
                        onepoleC.lowpassOut -> lowpassOut;
                    }
                }
            }    
        }

        /** A dummy processor that doesn't modify streams
        
            Use case: debugging
        */
        namespace TheDummy
        {
            using InType = SampleType;
            using OutType = SampleType;

            graph Processor()
            {
                input stream InType in;
                output stream OutType out;
                
                connection
                {
                    in -> out;
                }
            }
        }
    } //namespace HighLevel

/*==============================================================================
Filter Processors                                                       01/25/22
==============================================================================*/

    /** Ladder Low Pass Filter with variable order and saturating state 
    
        Notes:
        - currently hard-coded to 4th order lpf
        - Resonance up to 2 reccomended
        - Even though its nonlinear, the filter can become unstable if using an unbounded nonlinearity
          i.e., the filter can self-oscillate with nonlinear functions like 'tanh'
    */
    namespace LadderLpfS
    {       
        let oversampling = 2;

        graph Processor (float iCutoff, float iResonance, float iNonlinearity)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                smoothedParameter0.in0 cutoffIn [[ name: "Cutoff", min: 3000, max: 18000, init: iCutoff, unit: "Hz", step: 1 ]];
                smoothedParameter1.in0 resonanceIn [[ name: "Resonance", min: 0, max: 2, init: iResonance, step: 0.01f ]];
                internal.nonlinearityIn;
            }
    
            let
            {
                smoothedParameter0 = SmoothedParameter::Processor (float[] (iCutoff), SmoothedParameter::Modes::G_OnepoleToGain, oversampling);
                smoothedParameter1 = SmoothedParameter::Processor (float[] (iResonance), SmoothedParameter::Modes::GainToGain);
                
                internal = Internal::Processor (iNonlinearity) * oversampling;
            }
    
            connection
            {
                smoothedParameter0.out0 -> internal.G_OnepoleIn;
                smoothedParameter1.out0 -> internal.kIn;

                in -> internal.in;
                internal.out -> out;
            }
        }
    
        namespace Internal
        {   
            struct Coeffs
            {
                SampleType g; //G for onepole stages
                SampleType k; //resonance
                SampleType N; //nonlinearity
            }

            void updatePerSample (Coeffs& c, SampleType G_Onepole, SampleType k)
            {
                c.g = G_Onepole;
                c.k = k;
            }

            namespace M (int order)
            {
                static_assert (order % 2 == 0, "LadderFilter::M [[Filter Processors]]");

                void update (Coeffs& c, float nonlinearity, State& s, float64 fs)
                {
                    c.N = float (88200 / fs) * nonlinearity * (1.f + float (c.k[0])); //nonlinearity scaled according to fs and other params
                }

                struct State
                {
                    SampleType[order] s;
                }

                SampleType process (State& s, SampleType x, const Coeffs& c)
                {
                    var S = ZERO;
                    var G = ONE;
                    for (int i = order - 1; i > -1; --i)
                    {
                        S += G * s.s.at(i);
                        G *= c.g;
                    }

                    //input to first lowpass ('u')
                    var y = (x - c.k * S) / (ONE + c.k * G);

                    //'order' lowpasses in series
                    for (int i = 0; i < order; ++i)
                    {
                        let v = (y - s.s.at(i)) * c.g;
                        
                        y = vBBD(v  + s.s.at(i), c.N); // "state saturation"
                        s.s.at(i) = v + y;
                    }
                    
                    return y * (ONE + c.k); //normalize
                }
            }
        
            processor Processor (float iNonlinearity, int order = 4)
            {
                input stream SampleType in;
                output stream SampleType out;

                input stream SampleType G_OnepoleIn, kIn;

                input event float nonlinearityIn [[ name: "Nonlin", min: 0, max: 1, init: iNonlinearity, step: 0.01]];

                event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            
                float nonlinearity = iNonlinearity;
                bool recalc = true;

                static_assert (order == 4, "LadderLpfS::Processor [[Filter Processors]] Other filter orders not yet implemented.");
        
                void run()
                {   
                    M(order)::State s;
                    Coeffs c;

                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;

                            M(order)::update (c, nonlinearity, s, processor.frequency);
                        }

                        loop (updateIntervalSamples)
                        {
                            c.updatePerSample (G_OnepoleIn, kIn);                            

                            out << M(order)::process (s, in, c);

                            advance();
                        }
                    }
                }
            }
        }
    }

    /** Split into attack/release via IsolateAttackSustain */
    namespace SplitAttackSustain
    {
        graph Processor(float iAttack,
                        float iSustain,
                        float iSensitivity,
                        float iStereoLink)
        {
            input stream SampleType in;
            output stream SampleType attackOut, sustainOut;
    
            input
            {
                sustainIsolator.attackIn;
                sustainIsolator.sustainIn;
                sustainIsolator.sensitivityIn;
                sustainIsolator.stereoLinkIn;
            }
    
            let
            {
                sustainIsolator = SustainIsolator::Processor (iAttack, iSustain, iSensitivity, iStereoLink);

                difference = Difference::Processor;
            }
    
            connection
            {
                in -> sustainIsolator.in, difference.in0;

                sustainIsolator.out -> difference.in1, sustainOut;

                difference.out -> attackOut;
            }
        }
    }

    /** Ultrasonic blocker using a critically-damped svf */
    namespace UltraBlocker
    {
        graph Processor()
        {
            input stream SampleType in;
            output stream SampleType out;
    
            let
            {
                pSvf = filt::tpt::svf::Processor (16000, 0.4f);
            }
    
            connection
            {
                in -> pSvf.in;
                pSvf.lowpassOut -> out;
            }
        }
    }
    
    /** Split into high/low amplitude via downward compression or downward expansion */
    namespace SplitLoudSoft
    {
        graph Processor(float iThreshold,
                        float iRelease,
                        float iStereoLink)
        {
            input stream SampleType in;
            output stream SampleType loudOut, softOut;
    
            input
            {
                expressorClassical.thresholdIn;
                expressorClassical.releaseIn [[ name: "Release", min: 30, max: 999, init: iRelease, unit: "ms", step: 1 ]];
                expressorClassical.stereoLinkIn;
            }
    
            let
            {
                expressorClassical = ExpressorClassical::Processor (iStereoLink, 4, iRelease, iThreshold, 1, 0.25f);
                difference = Difference::Processor;
            }
    
            connection
            {
                in -> expressorClassical.in, difference.in0;
                expressorClassical.out -> loudOut, difference.in1;

                difference.out -> softOut;
            }
        }
    }
    
    /** Isolate the attack or sustain using 'DET' 
    
        attackIn is actually the effective attack
        time + 4 ms
    */
    namespace SustainIsolator
    {
        graph Processor(float iAttack,
                        float iSustain,
                        float iSensitivity,
                        float iStereoLink)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                det.release0In sustainIn [[ name: "Sustain", min: 30, max: 200, init: iSustain, step: 1, unit: "ms" ]];
                det.release1In attackIn [[ name: "Attack", min: 4, max: 25, init: iAttack, step: 1, unit: "ms" ]];       
                smoothedVolume.volumeIn sensitivityIn [[ name: "Sens", min: 0, max: 36, init: iSensitivity, step: 1, unit: "dB" ]];
                stereoLink.stereoLinkIn;
            }
    
            let
            {
                absADAA = AbsADAA::Processor * 2;
                stereoLink = StereoLink::Processor (iStereoLink);

                det = DET::Processor (4, iSustain, 4, iAttack);

                smoothedVolume = SmoothedVolume::Processor (iSensitivity);
                sigmoidC2 = SigmoidC2::Processor;

                applyGain = ApplyGain::Processor;
            }
    
            connection
            {
                in -> applyGain.in;

                in -> absADAA -> stereoLink.in;
                stereoLink.out -> det.in;
                det.out -> smoothedVolume.in;
                smoothedVolume.out -> sigmoidC2 -> applyGain.b;

                applyGain.out -> out;
            }
        }
    }

    /** Classical digital downwards/updawards ex(pander)/(com)pressor */
    namespace ExpressorClassical
    {
        graph Processor (float iStereoLink,
                        float iAttack,
                        float iRelease,
                        float iThreshold,
                        float iRatio0,
                        float iRatio1)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                stereoLink.stereoLinkIn;

                ballisticsFilter.attackIn;
                ballisticsFilter.releaseIn;

                ctf.thresholdIn;
                ctf.ratio0In;
                ctf.ratio1In;
            }
    
            let
            {
                absADAA = AbsADAA::Processor * 2;
                stereoLink = StereoLink::Processor (iStereoLink);
                ballisticsFilter = BallisticsFilter::Processor (iAttack, iRelease);
                ctf = CTF::Processor (iThreshold, iRatio0, iRatio1);

                applyGain = ApplyGain::Processor;
            }
    
            connection
            {
                in -> applyGain.in;

                in -> absADAA -> stereoLink.in;
                stereoLink.out -> ballisticsFilter.in;
                ballisticsFilter.out -> ctf.in;
                ctf.out -> applyGain.b;

                applyGain.out -> out;
            }
        }
    }

    /** Differential Envelope Technology
    
        Notes:
        - Use case: transient detection (use for attack or sustain)
        - See: https://spl.audio/en/spl-produkt/transient-designer-4/?v=fa868488740a
        - Also see: https://blog.audio-tk.com/2015/06/30/audio-toolkit-anatomy-of-a-transient-shaper/
    */
    namespace DET
    {
        graph Processor(float iAttack0,
                        float iRelease0,
                        float iAttack1,
                        float iRelease1)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                ballisticsFilter0.attackIn attack0In;
                ballisticsFilter0.releaseIn release0In;
                ballisticsFilter1.attackIn attack1In;
                ballisticsFilter1.releaseIn release1In; 
            }
    
            let
            {
                ballisticsFilter0 = BallisticsFilter::Processor (iAttack0, iRelease0);
                ballisticsFilter1 = BallisticsFilter::Processor (iAttack1, iRelease1);

                difference = Difference::Processor;
            }
    
            connection
            {
                in -> ballisticsFilter0.in, ballisticsFilter1.in;

                ballisticsFilter0.out -> difference.in0;
                ballisticsFilter1.out -> difference.in1;

                difference.out -> out;
            }
        }
    }

    /** Low pass filter with attack and release controls
    
        'OnepoleC' with differing cutoff depending on rising/falling output relative to stored output (feedback)
    */
    namespace BallisticsFilter
    {
        graph Processor (float iAttack,
                        float iRelease)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                internal.attackIn;
                internal.releaseIn;
            }
    
            let
            {
                internal = Internal::Processor (iAttack, iRelease);
                onepoleC = OnepoleC::Processor;
            }
    
            connection
            {
                in -> internal.x, onepoleC.in;

                onepoleC.lowpassOut -> [1] -> internal.y;
                internal.Omega -> onepoleC.Omega;

                onepoleC.lowpassOut -> out;
            }
        }

        namespace Internal
        {
            struct Coeffs 
            {
                SampleType OmegaA;
                SampleType OmegaR;
            }

            void update (Coeffs& c, float attack, float release) 
            {
                c.OmegaA = SampleType (1000.f / attack);
                c.OmegaR = SampleType (1000.f / release);
            }

            SampleType process (SampleType x, SampleType y, const Coeffs& c) 
            {
                return viflt (c.OmegaR, c.OmegaA, x, y);  
            }

            processor Processor(float iAttack,
                                float iRelease)
            {
                input stream SampleType x, y;
                output stream SampleType Omega;
        
                input event
                { 
                    float attackIn [[ name: "Attack", min: 0.1f, max: 50, init: iAttack, unit: "ms", step: 0.1 ]];
                    float releaseIn [[ name: "Release", min: 30, max: 3000, init: iRelease, unit: "ms", step: 1 ]];
                }

                event attackIn (float v) { attack = v; recalc = true; }
                event releaseIn (float v) { release = v; recalc = true; }

                float attack = iAttack;
                float release = iRelease;
                bool recalc = true;
        
                void run()
                {
                    Coeffs c;

                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;
        
                            c.update (attack, release);
                        }
        
                        loop (updateIntervalSamples)
                        {
                            Omega << process (x, y, c);

                            advance();
                        }
                    }
                }
            }
        }
    }

    /** Mix outputs from Onepole to make more complicated frequency responses */
    namespace OnepoleMixer
    {   
        namespace Modes
        {
            let HPF = 0;
            let LPF = 1;
            let APF = 2;
            let NumModes = 3;
        }

        struct Coeffs
        {
            int m;
        }
    
        void update (Coeffs& c, float mode)
        {
            c.m = int (mode);
        }
    
        SampleType process (SampleType hpf, SampleType lpf, const Coeffs& c)
        {
            if (c.m == Modes::HPF)
                return hpf;
            else if (c.m == Modes::LPF)
                return lpf;
            else
                return lpf - hpf;
        }
    
        processor Processor (int iMode)
        {
            input stream SampleType lowpassIn, highpassIn;
            output stream SampleType out;
    
            input event float modeIn [[ name: "Mode", min: Modes::HPF, max: Modes::NumModes - 1, init: iMode, text: "HPF|LPF|APF" ]];

            static_assert ((iMode > -1) && (iMode < Modes::NumModes), "OnepoleMixer::Processor [[Filter Processors]]");
    
            event modeIn (float v) { mode = v; recalc = true; }
    
            float mode = float (iMode);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (mode);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (highpassIn, lowpassIn, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** soul::filters::tpt::onepole modified for angular cutoff modulation
        
        - If sampling rate is 44.1kHz and an accurate frequency response is important, use 2x oversampling
        - Structure is more consistent with SVF and oversampling is used instead of prewarping when compared to soul::filters::tpt::onepole
    */
    namespace OnepoleC
    {   
        struct Coeffs
        {
            SampleType G;
        }

        struct State
        {
            SampleType s;
        }

        void updatePerSample (Coeffs& c, SampleType Omega, float64 fs)
        {
            c.G = vOmegaToG_Onepole (Omega, fs);
        }

        SampleType[2] process (State& s, SampleType x, const Coeffs& c)
        {
            let v = (x - s.s) * c.G;
            let lpf = v + s.s;
            let hpf = x - lpf;

            s.s = v + lpf;

            return SampleType[2] (lpf, hpf);
        }

        processor Processor
        {
            input stream SampleType in;
            input stream SampleType Omega;
            output stream SampleType lowpassOut, highpassOut;

            void run()
            {   
                State s;
                Coeffs c;

                loop
                {
                    c.updatePerSample (Omega, processor.frequency);

                    let y = process (s, in, c);

                    lowpassOut << y.at(0);
                    highpassOut << y.at(1);

                    advance();
                }
            }
        }
    }

    /** Modified version of https://soul.dev/lab/?id=Delay 
    
        For feedback make a loop with a unit delay (i.e. DelayLine.out -> [1] -> add your effects here -> DelayLine.in)
    */
    namespace DelayLine
    {   
        namespace M (float maxDelayMs, float maxDepthMs)
        {
            static_assert ((maxDelayMs + maxDepthMs) < float (INT_MAX_BUFFER_SIZE_MS), "DelayLine::M [[Filter Processors]]");
            
            let maxBufferSize = int (((maxDelayMs + maxDepthMs) / float (INT_MAX_BUFFER_SIZE_MS)) * float (INT_MAX_BUFFER_SIZE));

            struct State 
            {
                wrap<maxBufferSize> readPos, writePos;
                SampleType[maxBufferSize] buf;
            }

            void update (State& s, float delayMs, float64 fs)
            {
                let fsDiv1k = fs / 1000.f;

                s.readPos = wrap<maxBufferSize> (s.writePos - int (fsDiv1k * delayMs));
            }

            SampleType process (State& s, SampleType x, SampleType lfo, float64 fs)
            {
                let maxDepthSamples = float64 (maxDepthMs * fs / 1000.0);

                s.buf.at (s.writePos) = x;

                let l = s.buf.readLinearInterpolated (float64 (s.readPos) - maxDepthSamples * lfo[0]);
                let r = s.buf.readLinearInterpolated (float64 (s.readPos) - maxDepthSamples * lfo[1]);
                
                let y = l * CHANNEL_ZERO_MASK + r * CHANNEL_ONE_MASK;

                ++s.readPos;
                ++s.writePos;

                return y;
            }
        }

        processor Processor (float iDelayMs, float maxDelayMs, float maxDepthMs = 4)
        {
            input stream SampleType in;
            output stream SampleType out;

            input stream SampleType lfoIn; //unipolar, <= 1

            input event float delayIn [[ name: "Delay", min: 0, max: maxDelayMs, init: iDelayMs, unit: "ms", step: 1 /*UNSMOOTHED*/ ]];

            event delayIn (float v) { delayMs = v; recalc = true; }

            float delayMs = iDelayMs;
            bool recalc = true;

            static_assert (iDelayMs <= maxDelayMs, "DelayLine::Processor [[Filter Processors]]");

            namespace m = M (maxDelayMs, maxDepthMs);

            void run()
            {  
                m::State s;
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        m::update (s, delayMs, processor.frequency);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << m::process (s, in, lfoIn, processor.frequency);

                        advance();
                    }
                }
            }
        }
    }
    
/*==============================================================================
Vectorized Instrinsic/Helper Processors                                 01/26/22
==============================================================================*/
    
    /** 'vCTF_Color' wrapper */
    namespace CTF_Color
    {
        graph Processor(float iThreshold,
                        float iRatio0,
                        float iRatio1,
                        float iSoftness,
                        float iColor)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                smoothedParameter0.in0 thresholdIn [[ name: "Thresh", min: -50.f, max: 0.f, init: iThreshold, unit: "dB", step: 0.1f]];
                smoothedParameter1.in0 ratio0In [[ name: "Ratio (> Thr)", min: 0.5f, max: 20.f, init: iRatio0, step: 0.1f ]];
                smoothedParameter2.in0 ratio1In [[ name: "Ratio (< Thr)", min: 0.5f, max: 1.5f, init: iRatio1, step: 0.1f ]];
                smoothedParameter4.in0 softnessIn [[ name: "Softness", min: 0, max: 10, init: iSoftness, unit: "dB", step: 0.1f ]];
                smoothedParameter4.in0 colorIn [[ name: "Color", min: -24, max: 24, init: iColor, unit: "dB", step: 0.1f ]]; 
            }
    
            let
            {
                smoothedParameter0 = SmoothedParameter::Processor (float[] (iThreshold), SmoothedParameter::Modes::DecibelToDecibel);
                smoothedParameter1 = SmoothedParameter::Processor (float[] (iRatio0), SmoothedParameter::Modes::RatioToRatio);
                smoothedParameter2 = SmoothedParameter::Processor (float[] (iRatio1), SmoothedParameter::Modes::RatioToRatio);
                smoothedParameter3 = SmoothedParameter::Processor (float[] (iSoftness), SmoothedParameter::Modes::DecibelToDecibel);
                smoothedParameter4 = SmoothedParameter::Processor (float[] (iColor), SmoothedParameter::Modes::DecibelToDecibel);

                internal = Internal::Processor;
            }
    
            connection
            {
                smoothedParameter0.out0 -> internal.thresholdIn;
                smoothedParameter1.out0 -> internal.ratio0In;
                smoothedParameter2.out0 -> internal.ratio1In;
                smoothedParameter3.out0 -> internal.softnessIn;
                smoothedParameter4.out0 -> internal.colorIn;

                in -> internal.in;
                internal.out -> out;
            }
        }

        namespace Internal
        {
            struct Coeffs 
            {
                SampleType threshold;
                SampleType ratio0;
                SampleType ratio1;
                SampleType softness;
                SampleType color; 
            }
        
            void updatePerSample (Coeffs& c, SampleType threshold, SampleType ratio0, SampleType ratio1, SampleType softness, SampleType color) 
            {
                c.threshold = threshold;
                c.ratio0 = ratio0;
                c.ratio1 = ratio1;
                c.softness = softness;
                c.color = color;
            }
        
            SampleType process (SampleType x, const Coeffs& c) 
            {
                return vCTF_Color (x, c.threshold, c.ratio0, c.ratio1, c.softness, c.color);
            }

            processor Processor()
            {
                input stream SampleType in;
                input stream SampleType thresholdIn, ratio0In, ratio1In, softnessIn, colorIn;
                output stream SampleType out;

                void run()
                {
                    Coeffs c;

                    loop
                    {
                        c.updatePerSample (thresholdIn, ratio0In, ratio1In, softnessIn, colorIn);

                        out << process (in, c);
    
                        advance();
                    
                    }
                }
            }
        }
    }

    /** 'vCTF' wrapper */
    namespace CTF
    {
        graph Processor(float iThreshold,
                        float iRatio0,
                        float iRatio1)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                smoothedParameter0.in0 thresholdIn [[ name: "Thresh", min: -50.f, max: 0.f, init: iThreshold, unit: "dB", step: 0.1f]];
                smoothedParameter1.in0 ratio0In [[ name: "Ratio (> Thr)", min: 0.5f, max: 20.f, init: iRatio0, step: 0.1f ]];
                smoothedParameter2.in0 ratio1In [[ name: "Ratio (< Thr)", min: 0.5f, max: 1.5f, init: iRatio1, step: 0.1f ]];
            }
    
            let
            {
                smoothedParameter0 = SmoothedParameter::Processor (float[] (iThreshold), SmoothedParameter::Modes::DecibelToDecibel);
                smoothedParameter1 = SmoothedParameter::Processor (float[] (iRatio0), SmoothedParameter::Modes::RatioToRatio);
                smoothedParameter2 = SmoothedParameter::Processor (float[] (iRatio1), SmoothedParameter::Modes::RatioToRatio);

                internal = Internal::Processor;
            }
    
            connection
            {
                smoothedParameter0.out0 -> internal.thresholdIn;
                smoothedParameter1.out0 -> internal.ratio0In;
                smoothedParameter2.out0 -> internal.ratio1In;

                in -> internal.in;
                internal.out -> out;
            }
        }
        
        namespace Internal
        {
            struct Coeffs 
            {
                SampleType threshold;
                SampleType ratio0;
                SampleType ratio1;
            }
        
            void updatePerSample (Coeffs& c, SampleType threshold, SampleType ratio0, SampleType ratio1) 
            {
                c.threshold = threshold;
                c.ratio0 = ratio0;
                c.ratio1 = ratio1;
            }
        
            SampleType process (SampleType x, const Coeffs& c) 
            {
                return vCTF (x, c.threshold, c.ratio0, c.ratio1);
            }

            processor Processor()
            {
                input stream SampleType in;
                input stream SampleType thresholdIn, ratio0In, ratio1In;
                output stream SampleType out;

                void run()
                {
                    Coeffs c;
                
                    loop
                    {
                        c.updatePerSample (thresholdIn, ratio0In, ratio1In);

                        out << process (in, c);

                        advance();
                    }
                }
            }
        }
    }

    /** Split into center/sides using StereoLink */
    namespace SplitCenterSides
    {
        graph Processor (float iCenterSides)
        {
            input stream SampleType in;
            output stream SampleType centerOut, sidesOut;
    
            input
            {
                stereoLink.stereoLinkIn centerSidesIn [[ name: "C/S", min: 0, max: 100, init: iCenterSides, unit: "%", step: 1 ]];
            }
    
            let
            {
                stereoLink = StereoLink::Processor (iCenterSides);
                difference = Difference::Processor;
            }
    
            connection
            {
                in -> stereoLink.in, difference.in0;
                stereoLink.out -> difference.in1, centerOut;

                difference.out -> sidesOut;
            }
        }
    }

    /** 'vStereoLink' wrapper */
    namespace StereoLink
    {   
        struct Coeffs
        {
            float stereoLink;
        }
    
        void update (Coeffs& c, float stereoLink)
        {
            c.stereoLink = stereoLink;
        }
    
        SampleType process (SampleType x, const Coeffs& c)
        {
            return vStereoLink (x, c.stereoLink);
        }
    
        processor Processor (float iStereoLink)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float stereoLinkIn [[ name: "Link", min: 0, max: 100, init: iStereoLink, unit: "%", step: 1 ]];
            
            event stereoLinkIn (float v) { stereoLink = v; recalc = true; }

            float stereoLink = iStereoLink;
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency/44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (stereoLink);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (in, c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** 'vLan' wrapper with ADAA and a linear angular cutoff of 2pi
    
        Notes:
        - Optimized for use with 'OnepoleC' or modulating frequency domain filters
        - Use with 2x oversampling
    */
    namespace LanADAA
    {   
        struct Coeffs
        {
            SampleType N;
        }
    
        void update (Coeffs& c, float nonlinearity)
        {
            c.N = SampleType (nonlinearity);
        }    
    
        SampleType f (SampleType x, const Coeffs& c)
        {
            return vLan (x, c.N);
        }
    
        SampleType F1 (SampleType x, const Coeffs& c)
        {
            return vpow (x, 3) * vpow (c.N, 2) * SampleType (1.0 / 3.0) + c.N * vpow (x, 2) * vSgn (x) + x;
        }
    
        SampleType F2 (SampleType x, const Coeffs& c)
        {
            return vpow (x, 2) * (HALF + c.N * SampleType (1.0 / 3.0) * x * vSgn (x) + vpow (c.N, 2) * SampleType (1.0 / 12.0) * vpow (x, 2));
        }
    
        struct State
        {
            SampleType x_2;
            SampleType x_1;
            SampleType F2_1;
            SampleType F1_1;
        }
    
        void reset (State& s)
        {
            s.x_2 = ZERO;
            s.x_1 = ZERO;
            s.F2_1 = ZERO;
            s.F1_1 = ZERO;
        }

        SampleType processADAA2 (State& s, SampleType x, const Coeffs& c)
        {
            //Find F1_0
            let x_0mx_1 = x - s.x_1;
            let F2_0 = F2 (x, c);
    
            let F1_0 = viflt (F1 (HALF * (x + s.x_1), c), 
                (F2_0 - s.F2_1) / x_0mx_1,
                vabs (x_0mx_1), ADAA_TOL);
    
            //Find f_0
            let x_0mx_2 = x - s.x_2;
    
            let xBar = HALF * (x + s.x_2);
            let delta = xBar - s.x_1;
    
            let f_0 = viflt (
                viflt (
                    f (HALF * (xBar + s.x_1), c),
                    (TWO / delta) * (F1 (xBar, c) + (s.F2_1 - F2 (xBar, c)) / delta),
                    vabs (delta), ADAA_TOL
                ),
                (TWO / (x_0mx_2)) * (F1_0 - s.F1_1),
                vabs (x_0mx_2), ADAA_TOL
            );
    
            //update s
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType process (State& s, SampleType x, const Coeffs& c)
        {
            return s.processADAA2 (x, c);
        }
    
        processor Processor (float iNonlinearity)
        {
            input stream SampleType in;
            output stream SampleType Omega;

            input event float nonlinearityIn [[ name: "Nonlin", min: 0, max: 350, init: iNonlinearity, step: 1 /*UNSMOOTHED*/ ]];

            event nonlinearityIn (float v) { nonlinearity = v; recalc = true; }
            
            float nonlinearity = iNonlinearity;
            bool recalc = true;

            void run()
            {
                State s;
                Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;

                        c.update (nonlinearity);
                        s.reset();
                    }

                    loop (updateIntervalSamples)
                    {
                        Omega << (SampleType (twoPi - 1) + s.process (in, c));

                        advance();
                    }
                }
            }
        }
    }

    /** 'vSigmoidC2' wrapper */
    namespace SigmoidC2
    {   
        processor Processor ()
        {
            input stream SampleType in;
            output stream SampleType out;
    
            void run()
            {   
                loop
                {
                    out << vSigmoidC2 (in);

                    advance();
                }
            }
        }
    }

    /** 'vabs' wrapper with ADAA
    
        Notes:
        - Dynamic ADAA specifically optimized for signal rectification (see 'TheExpressor' and 'ExpressorClassical')
    */
    namespace AbsADAA
    {   
        struct Coeffs
        {
        }
    
        SampleType f (SampleType x, const Coeffs& c)
        {
            return vabs (x);
        }
    
        SampleType F1 (SampleType x, const Coeffs& c)
        {
            return vSgn(x) * HALF * vpow (x, 2);
        }
    
        SampleType F2 (SampleType x, const Coeffs& c)
        {
            return vSgn (x) * SampleType (1.0 / 6.0) * vpow (x, 3);
        }

        SampleType F3 (SampleType x, const Coeffs& c)
        {
            return vSgn(x) * SampleType (1.0 / 24.0) * vpow (x, 4);
        }
    
        struct State
        {
            SampleType x_3;
            SampleType x_2;
            SampleType x_1;
            SampleType F3_1;
            SampleType F2_1;
            SampleType F1_1;
        }
    
        void reset (State& s)
        {
            s.x_2 = ZERO;
            s.x_1 = ZERO;
            s.F2_1 = ZERO;
            s.F1_1 = ZERO;
        }
    
        SampleType processADAA3 (State& s, SampleType x, const Coeffs& c)
        {
            //F2_0
            let x_0mx_1 = x - s.x_1;
            let F3_0 = F3 (x, c);

            let F2_0 = viflt (
                F2 (HALF * (x + s.x_1), c), 
                (F3_0 - s.F3_1) / x_0mx_1,
                vabs (x_0mx_1), 
                ADAA_TOL
            );

            //Find F1_0
            let x_0mx_2 = x - s.x_2;
    
            let xBar = HALF * (x + s.x_2);
            let delta = xBar - s.x_1;
    
            let F1_0 = viflt (
                viflt (
                    F1 (HALF * (xBar + s.x_1), c),
                    (TWO / delta) * (F2 (xBar, c) + (s.F3_1 - F3 (xBar, c)) / delta),
                    vabs (delta), ADAA_TOL
                ),
                (TWO / (x_0mx_2)) * (F2_0 - s.F2_1),
                vabs (x_0mx_2), 
                ADAA_TOL
            );

            //Find f_0
            let x_1mx_2 = s.x_1 - s.x_2;
    
            let f_0 = viflt (f (HALF * (s.x_1 + s.x_2), c), 
                (F1_0 - s.F1_1) / x_1mx_2,
                vabs (x_1mx_2), 
                ADAA_TOL);

            //update s
            s.x_3 = s.x_2;
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F3_1 = F3_0;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;

            return f_0;
        }

        SampleType processADAA2 (State& s, SampleType x, const Coeffs& c)
        {
            //Find F1_0
            let x_0mx_1 = x - s.x_1;
            let F2_0 = F2 (x, c);
    
            let F1_0 = viflt (F1 (HALF * (x + s.x_1), c), 
                (F2_0 - s.F2_1) / x_0mx_1,
                vabs (x_0mx_1), ADAA_TOL);
    
            //Find f_0
            let x_0mx_2 = x - s.x_2;
    
            let xBar = HALF * (x + s.x_2);
            let delta = xBar - s.x_1;
    
            let f_0 = viflt (
                viflt (
                    f (HALF * (xBar + s.x_1), c),
                    (TWO / delta) * (F1 (xBar, c) + (s.F2_1 - F2 (xBar, c)) / delta),
                    vabs (delta), ADAA_TOL
                ),
                (TWO / (x_0mx_2)) * (F1_0 - s.F1_1),
                vabs (x_0mx_2), ADAA_TOL
            );
    
            //update s
            s.x_2 = s.x_1;
            s.x_1 = x;
            s.F2_1 = F2_0;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType processADAA1 (State& s, SampleType x, const Coeffs& c)
        {
            //Find f_0
            let x_0mx_1 = x - s.x_1;
            let F1_0 = F1 (x, c);
    
            let f_0 = viflt (f (HALF * (x + s.x_1), c), 
                (F1_0 - s.F1_1) / x_0mx_1,
                vabs (x_0mx_1), ADAA_TOL);
    
            //update s
            s.x_1 = x;
            s.F1_1 = F1_0;
    
            return f_0;
        }
    
        SampleType process (State& s, SampleType x, const Coeffs& c)
        {
            return s.processADAA2(x, c);
        }
    
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                State s;
                Coeffs c;
    
                loop
                {
                    out << s.process (in, c);

                    advance();
                }
            }
        }
    }
    
    namespace Abs
    {
        processor Processor()
        {
            input stream SampleType in;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << vabs (in);

                    advance();
                }
            }
        }
    }

    /** out = b * in */
    namespace ApplyGain
    {
        processor Processor
        {
            input stream SampleType b;
            input stream SampleType in;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << b * in;
    
                    advance();
                }
            }
        }
    }

    /** out = b0 * in0 + b1 * in1 */
    namespace ApplyGains
    {
        processor Processor
        {
            input stream SampleType b0, b1;
            input stream SampleType in0, in1;
            output stream SampleType out;
    
            void run()
            {
                loop
                {
                    out << b0 * in0 + b1 * in1;
    
                    advance();
                }
            }
        }
    }

    /** Output 1 of 4 signals */
    namespace Mux4To1
    {   
        struct Coeffs
        {
            int idx;
        }
    
        void update (Coeffs& c, float idx)
        {
            c.idx = int (floor (idx));
        }
    
        SampleType process (SampleType[4] x, const Coeffs& c)
        {
            return x.at (c.idx);
        }
    
        processor Processor (int iIdx)
        {
            input stream SampleType in0, in1, in2, in3;
            output stream SampleType out;
    
            input event float idxIn [[ name: "idx", min: 0, max: 3, init: iIdx, step: 1 /*UNSMOOTHED*/ ]];
    
            event idxIn (float v) { idx = v; recalc = true; }
    
            float idx = float (iIdx);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (idx);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (SampleType[4] (in0, in1, in2, in3), c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Output 1 of 3 signals */
    namespace Mux3To1
    {   
        struct Coeffs
        {
            int idx;
        }
    
        void update (Coeffs& c, float idx)
        {
            c.idx = int (floor (idx));
        }
    
        SampleType process (SampleType[3] x, const Coeffs& c)
        {
            return x.at (c.idx);
        }
    
        processor Processor (int iIdx)
        {
            input stream SampleType in0, in1, in2;
            output stream SampleType out;
    
            input event float idxIn [[ name: "idx", min: 0, max: 2, init: iIdx, step: 1 /*UNSMOOTHED*/ ]];
    
            event idxIn (float v) { idx = v; recalc = true; }
    
            float idx = float (iIdx);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (idx);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (SampleType[3] (in0, in1, in2), c);
    
                        advance();
                    }
                }
            }
        }
    }

    /** Output 1 of 2 signals */
    namespace Mux2To1
    {   
        struct Coeffs
        {
            int idx;
        }
    
        void update (Coeffs& c, float idx)
        {
            c.idx = int (floor (idx));
        }
    
        SampleType process (SampleType[2] x, const Coeffs& c)
        {
            return x.at (c.idx);
        }
    
        processor Processor (int iIdx)
        {
            input stream SampleType in0, in1;
            output stream SampleType out;
    
            input event float idxIn [[ name: "idx", min: 0, max: 1, init: iIdx, step: 1 /*UNSMOOTHED*/ ]];
    
            event idxIn (float v) { idx = v; recalc = true; }
    
            float idx = float (iIdx);
            bool recalc = true;
    
            void run()
            {   
                Coeffs c;
    
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
    
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        c.update (idx);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        out << process (SampleType[2] (in0, in1), c);
    
                        advance();
                    }
                }
            }
        }
    }

    namespace Max
    {   
        processor Processor()
        {
            input stream SampleType a, b;
            output stream SampleType out;

            void run()
            {   
                loop
                {
                    out << vmax (a, b);

                    advance();
                }
            }
        }
    }

    namespace Sum
    {
        processor Processor()
        {
            input stream SampleType in0, in1;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << in0 + in1;

                    advance();
                }
            }
        }
    }
    
    namespace Difference
    {
        processor Processor()
        {
            input stream SampleType in0, in1;
            output stream SampleType out;

            void run()
            {
                loop
                {
                    out << in0 - in1;

                    advance();
                }
            }
        }
    }
    
    namespace Constant
    {
        processor Processor(float iConstant)
        {
            output stream SampleType out;

            let constant = SampleType (iConstant);

            void run()
            {
                loop
                {
                    out << constant;

                    advance();
                }
            }
        }
    }

    namespace Variable
    {   
        processor Processor (float iVariable)
        {
            output stream SampleType out;

            input event float variableIn [[ name: "Variable", min: 0, max: 1, init: initialVariable, step: 0.01 ]];
    
            event variableIn (float v) { variable = SampleType (v); }
    
            SampleType variable = SampleType (iVariable);
            bool recalc = true;
    
            void run()
            {   
                loop
                {
                    out << variable;

                    advance();
                }
            }
        }
    }

    namespace SampleTypesToSampleType2
    {   
        processor Processor ()
        {
            input stream SampleType in0, in1;
            output stream SampleType.elementType<4> out;

            void run()
            {   
                loop
                {
                    out << vSampleTypesToSampleType2 (in0, in1);

                    advance();
                }
            }
        }
    }

    namespace SampleType2ToSampleTypes
    {
        processor Processor ()
        {
            input stream SampleType2 in;
            output stream SampleType out0, out1;

            void run()
            {   
                loop
                {
                    out0 << SampleType (in[0], in[1]);
                    out1 << SampleType (in[2], in[3]);

                    advance();
                }
            }
        }
    }

/*==============================================================================
Mix Processors                                                          01/18/22
==============================================================================*/
    
    /** Apply a volume via 'AutoParameter' and 'SmoothedVolume' */
    namespace AutoSmoothedVolume
    {
        graph Processor(int mode)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input
            {
                autoParameter.parameterIn;
                autoParameter.controlIn;
            }
    
            let
            {
                autoParameter = AutoParameter::Processor (mode);
                smoothedVolume = SmoothedVolume::Processor (AutoParameter::M(mode)::iParameter);
            }
    
            connection
            {
                autoParameter.out -> smoothedVolume.volumeIn;

                in -> smoothedVolume.in;
                smoothedVolume.out -> out;
            }
        }
    }

    /** Apply mixing and panning via 'SmoothedParameter' */
    namespace SmoothedMixPan
    {
        graph Processor(float iMix, float iPan)
        {
            input stream SampleType in0, in1;
            output stream SampleType out;
    
            input
            {
                smoothedGains.in0 mixIn [[ name: "Mix", min: 0, max: 100, init: iMix, unit: "%", step: 1 ]];
                smoothedGains.in1 panIn [[ name: "Pan", min: -1, max: 1, init: iPan, step: 0.01f ]];
            }

            let
            {
                smoothedGains = SmoothedParameter::Processor (float[2] (iMix, iPan), SmoothedParameter::Modes::MixPanToGains);
                applyGains = ApplyGains::Processor;
            }
    
            connection
            {
                smoothedGains.out0 -> applyGains.b0;
                smoothedGains.out1 -> applyGains.b1;

                in0 -> applyGains.in0;
                in1 -> applyGains.in1;

                applyGains.out -> out;
            }
        }
    }
    
    /** Apply a volume via 'SmoothedParameter' */
    namespace SmoothedVolume
    {
        graph Processor (float iVolume)
        {
            input stream SampleType in;
            output stream SampleType out;
    
            input event float volumeIn [[ name: "Volume", min: -12, max: 0, init: iVolume, step: 0.1f, unit: "dB" ]];
    
            let
            {
                smoothedGain = SmoothedParameter::Processor (float[] (iVolume), SmoothedParameter::Modes::DecibelToGain);
                applyGain = ApplyGain::Processor;
            }
    
            connection
            {
                in -> applyGain.in;
                
                volumeIn -> smoothedGain.in0;
                smoothedGain.out0 -> applyGain.b;

                applyGain.out -> out;
            }
        }
    }

/*==============================================================================
Parameter Processors                                                    01/26/22
==============================================================================*/

    /** Modified version of soul::oscillators::lfo 
    
        Notes:
        - Stereo output with ability to shift phase of the left channel ('widthIn')
        - Unipolar only
        - No beat sync or random lfos
    */
    namespace Lfo
    {   
        namespace Modes
        {
            let Triangle = 0;
            let Sine = 1;
            let NumModes = 2;
        }

        graph Processor (float iDepth,
                        float iRate,
                        float iWidth,
                        int iMode)
        {
            output stream SampleType out;
    
            input
            {
                smoothedParameter0.in0 depthIn [[ name: "Depth", min: 0, max: 100, init: iDepth, unit: "%", step: 1 ]];
                internal.rateIn;
                internal.widthIn;
                internal.modeIn;
            }
    
            let
            {
                smoothedParameter0 = SmoothedParameter::Processor (float[] (iDepth), SmoothedParameter::Modes::PercentToGain);
                
                internal = Internal::Processor (iRate, iWidth, iMode);
            }
    
            connection
            {
                smoothedParameter0.out0 -> internal.depthIn;

                internal.out -> out;
            }
        }

        namespace Internal
        {

            struct Coeffs
            {
                SampleType depth;
                SampleType phaseIncrement;
                int mode;
            }

            struct State
            {
                SampleType phase;
            }

            void updatePerSample (Coeffs& c, SampleType depth)
            {
                c.depth = depth;
            }

            void update (Coeffs& c, float rate, float width, float mode, State& s, float64 fs)
            {
                let T = 1.0 / fs;

                c.phaseIncrement = SampleType (rate * T);
                
                s.phase[0] = s.phase[1] + float64 (width * (1.f / 360.f));
                while (s.phase[0] < 0.0)
                    s.phase[0] += 1.0;
                while (s.phase[0] >= 1.0)
                    s.phase[0] -= 1.0;

                c.mode = int (floor (mode));
            }

            SampleType process (State& s, const Coeffs& c)
            {
                var y = ZERO;

                if (c.mode == Modes::Triangle)      
                    y = ONE - vabs((s.phase * TWO) - ONE );
                else if (c.mode == Modes::Sine)          
                    y = (sin (s.phase * SampleType (twoPi)) + ONE) * HALF;

                s.phase += c.phaseIncrement;

                while (s.phase[0] >= 1.0)
                    s.phase[0] -= 1.0;
                while (s.phase[1] >= 1.0)
                    s.phase[1] -= 1.0;
            
                return y * c.depth;
            }

            processor Processor (float iRate,
                                 float iWidth,
                                 int iMode)
            {
                output stream SampleType out;
                
                input stream SampleType depthIn;

                input event
                {
                    float rateIn [[ name: "Rate", min: 0.1, max: 4, init: iRate, unit: "Hz", step: 0.01 ]];
                    float widthIn [[ name: "Width", min: -180, max: 180, init: iWidth, unit: "deg", step: 1 /*UNSMOOTHED*/ ]];
                    float modeIn [[ name: "Mode", min: 0, max: 1, init: iMode, text: "Tri|Sine" /*UNSMOOTHED*/ ]];
                }

                event rateIn (float v) { rate = v; recalc = true; }
                event widthIn (float v) { width = v; recalc = true; }
                event modeIn (float v) { mode = v; recalc = true; }

                float rate = iRate;
                float width = iWidth;
                float mode = float (iMode);

                bool recalc = true;

                void run()
                {
                    State s;
                    Coeffs c;

                    let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
        
                    loop
                    {
                        if (recalc)
                        {
                            recalc = false;

                            c.update (rate, width, mode, s, processor.frequency);
                        }

                        loop (updateIntervalSamples)
                        {          
                            c.updatePerSample (depthIn);

                            out << process (s, c);

                            advance();
                        }
                    }
                }
            }
        }
    }

    /** Automatic/manual parameters

        Notes:
        - Use to control a event float endpoint
        - Passes events from 'parameterIn' to 'out' unless the current value of 'parameterIn' is below the mode's MinManualParameter.
        'controlIn' is mapped to 'out' in this case ('out' is automatically determined by 'controlIn')
        - Currently only for makeup volume
    */
    namespace AutoParameter
    {   
        namespace Modes
        {
            let Volume_OnepoleC_Lan = 0;
            let NumModes = 1;
        }

        namespace M (int mode)
        {
            static_assert ((mode > -1) && (mode < Modes::NumModes), "AutoParameter [[Parameter Processors]]");

            let MaxParameter = (mode == Modes::Volume_OnepoleC_Lan ? 0.f : 0.f);
            let MinParameter = (mode == Modes::Volume_OnepoleC_Lan ? -6.1f : -6.1f);
            let iParameter = (mode == Modes::Volume_OnepoleC_Lan ? MinParameter : MinParameter);
            let Step = (mode == Modes::Volume_OnepoleC_Lan ? 0.1f : 0.1f);
            let MinManualParameter = (mode == Modes::Volume_OnepoleC_Lan ? MinParameter + Step : MinParameter + Step);
            let PtsSize = (mode == Modes::Volume_OnepoleC_Lan ? 4 : 1);
            let Pts = (mode == Modes::Volume_OnepoleC_Lan ? float[PtsSize] (-0.f, -1.f, -2.f, -3.5f) : float[PtsSize] (0));

            float update (float parameter, float control)
            {
                if (parameter < MinManualParameter)
                {
                    if const (mode == Modes::Volume_OnepoleC_Lan)
                        return Pts.readLinearInterpolated (min (control * 0.1f, 3.f));
                }
                else
                    return parameter; 
            }
        }

        processor Processor (int mode)
        {
            output event float out;

            input event float parameterIn [[name: "Volume", min: M (mode)::MinParameter, max: M(mode)::MaxParameter, init: M(mode)::iParameter, step: M(mode)::Step, unit: "dB"]];
            input event float controlIn;

            event parameterIn (float v) { parameter = v; recalc = true; }
            event controlIn (float v) { control = v; recalc = true; }

            float parameter = M(mode)::iParameter;
            float control;
            bool recalc = true;

            void run() 
            { 
                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        out << M(mode)::update (parameter, control);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        advance();
                    }
                }
            }
        }
    }

    /** Maps float event(s) to smoothed SampleType stream(s); heavily modified version of soul::gain::SmoothedGainParameter

        Note:
        - float event(s) are smoothed s.t. their maximum sine modulation frequency that preserves their amplitude is 50 Hz
        - iParameter is a float[] that defines the initial value of the parameter(s) corresponding to each of the float event(s)
        - This Processor may be modified in the future to include other one-to-one, one-to-two, two-to-one, or two-to-two event-stream mapping Modes
    */       
    namespace SmoothedParameter
    {
        let DOUBLE_SLEW_RATE_SECONDS_GAIN = 100.0; //1 unit unipolar sine period is approx 2 units of movement (i.e. the sine modulates b/w 0 and 1); 100/2 = 50 Hz 
        let DOUBLE_SLEW_RATE_SECONDS_DECIBEL = 5000.0; //1 unit unipolar sine period is approx 100dBs of movement; 5000/100 = 50 Hz  
        let DOUBLE_SLEW_RATE_SECONDS_RATIO = 2000.0; //1 unit unipolar sine period is approx 40 units of movement; 2000/40 = 50 Hz

        namespace Modes
        {
            let GainToGain = 0;
            let DecibelToGain = 1;
            let MixPanToGains = 2;
            let G_OnepoleToGain = 3;
            let PercentToGain = 4;
            let DecibelToDecibel = 5;
            let RatioToRatio = 6;
            let NumModes = 7;
        }

        namespace M (int mode)
        {
            static_assert ((mode > -1) && (mode < Modes::NumModes), "SmoothedParameter::M [[Parameter Processors]]");

            let SlewRateSeconds = (mode == Modes::DecibelToDecibel? DOUBLE_SLEW_RATE_SECONDS_DECIBEL: (mode== Modes::RatioToRatio ? DOUBLE_SLEW_RATE_SECONDS_RATIO : DOUBLE_SLEW_RATE_SECONDS_GAIN));
            
            let NumIn = (mode == Modes::MixPanToGains ? 2 : 1);
            let NumOut = (mode == Modes::MixPanToGains ? 2 : 1);

            struct Coeffs
            {
                SampleType[NumOut] target;
                SampleType[NumOut] increment;
            }

            struct State
            {
                SampleType[NumOut] current;
                int remainingRampSamples;
            }

            SampleType[NumOut] decodeParameter (float[] parameter, float64 fs)
            {
                SampleType[NumOut] y;

                if const (mode == Modes::GainToGain || mode == Modes::DecibelToDecibel || mode == Modes::RatioToRatio)
                    y.at(0) = SampleType (parameter.at(0));
                else if const (mode ==  Modes::DecibelToGain)
                    y.at(0) = vdBtoGain (SampleType (parameter.at(0)));
                else if const (mode == Modes::MixPanToGains)
                    y = vMixPanToGains (parameter.at(0), parameter.at(1));
                else if const (mode == Modes::G_OnepoleToGain)
                    y.at(0) = vCutoffToG_Onepole (parameter.at(0), fs); 
                else if const (mode == Modes::PercentToGain)
                    y.at(0) = parameter.at(0) * 0.01;

                return y;
            }

            void update (Coeffs& c, float[] parameter, State& s, SampleType divMaxDelta, float64 fs)
            {
                c.target = decodeParameter (parameter, fs);

                if const (mode != Modes::MixPanToGains)
                    s.remainingRampSamples = int (vmax (ONE, vabs (c.target.at(0) - s.current.at(0)) * divMaxDelta) [0]);
                else if const (mode == Modes::MixPanToGains)
                {
                    let r0 = int (vmaxr (vabs (c.target.at(0) - s.current.at(0)) * divMaxDelta));
                    let r1 = int (vmaxr (vabs (c.target.at(1) - s.current.at(1)) * divMaxDelta));
                    s.remainingRampSamples = max (1, max (r0, r1));
                }

                for (int i = 0; i < NumOut; ++i)
                    c.increment.at(i) = (c.target.at(i) - s.current.at(i)) / SampleType (s.remainingRampSamples);
            }

            void updateUnsmoothed (Coeffs& c, float[] parameter, State& s, float64 fs)
            {
                c.target = decodeParameter (parameter, fs);

                s.remainingRampSamples = 1;
            }

            SampleType[NumOut] process (State& s, const Coeffs& c)
            {
                if (s.remainingRampSamples != 0)
                {
                    if (--(s.remainingRampSamples) == 0)
                    {
                        for (int i = 0; i < s.current.size; ++i)
                            s.current.at(i) = c.target.at(i);
                    }
                    else
                    {
                        for (int i = 0; i < s.current.size; ++i)
                            s.current.at(i) += c.increment.at(i);
                    }
                }

                return s.current;
            }
        }

        processor Processor (float[] iParameter, int mode, int oversampling = 1)
        {
            output stream SampleType out0, out1;

            input event float in0, in1;

            event in0 (float v) { parameter.at(0) = v; recalc = true; }
            event in1 (float v) { parameter.at(1) = v; recalc = true; }

            float[2] parameter;
            bool recalc = false;

            static_assert (iParameter.size <= parameter.size, "SmoothedParameter::Processor [[Parameter Processors]]");
            static_assert (oversampling > 0, "SmoothedParameter::Processor [[ParameterProcessors]]");

            void init()
            {
                for (int i = 0; i < iParameter.size; ++i)
                    parameter.at(i) = iParameter.at(i);
            }

            void run()
            {   
                M(mode)::State s;
                M(mode)::Coeffs c;

                let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);
                let divMaxDelta = SampleType (processor.frequency / M(mode)::SlewRateSeconds);
                let fs = processor.frequency * float64 (oversampling);
    
                M(mode)::updateUnsmoothed (c, parameter, s, fs);
            
                loop
                {
                    if (recalc)
                    {
                        recalc = false;
    
                        M(mode)::update (c, parameter, s, divMaxDelta, fs);
                    }
    
                    loop (updateIntervalSamples)
                    {
                        let y = M(mode)::process (s, c);

                        out0 << y.at(0);

                        if const (M(mode)::NumOut > 1)
                            out1 << y.at(1);

                        advance();
                    }
                }
            }
        }
    }

/*==============================================================================
Vectorized Helper Functions                                             01/18/22
==============================================================================*/

    /** 'vCTF' with additional color settings to shape the knee 
    
        Parameters:
        - ratio0: ratio above threshold (> 1 is downward compression, < 1 is upward expansion)
        - ratio1: ratio below threshold (> 1 is upward compression, < 1 is downward expansion)
        - height: color height in dB
        - width: color width in dB (internally limited to [3, inf))
        - softness: width of the quadratic interpolation in dB

        Notes:
        - gain is limited to (0, 1.9] (BIBO stable)
        - At extremely high height parameters, the CTF becomes a 'swell' function
        - Algebraic bell-shaped function (derivative of a sigmoidal function arctan) used for color;
          This is cheap to compute and modulation stable
        - Soft knee is quadratic interpolation given y and dy/dx at xdB = T + softness/2 and T - softness/2 
        - See https://blog.audio-tk.com/2015/09/08/audio-toolkit-additional-gain-functions/
        - See https://people.math.sc.edu/kellerlv/Quadratic_Interpolation.pdf
    */
    SampleType vCTF_Color (SampleType x, SampleType threshold, SampleType ratio0, SampleType ratio1, SampleType softness, SampleType color)
    {
        //dB scale
        let xdB = vGainTodB (x);
        let xdBmthr = xdB - threshold;

        //constants
        let divRatio0 = ONE/ratio0;
        let divRatio1 = ONE/ratio1;
        let softnessDiv2 = softness * HALF;
        let thresholdPlus = threshold + softnessDiv2;
        let divRatioDiffDivSoftness = (divRatio0 - divRatio1) / vmax (softness, ADAA_TOL);

        //softness
        let c = HALF * divRatioDiffDivSoftness;
        let b = divRatio0 - divRatioDiffDivSoftness * thresholdPlus;
        let a = threshold - threshold * divRatio0 + c * vpow (thresholdPlus, 2);
        let softKnee = a  + b * xdB + c * vpow (xdB, 2);

        //color
        let divColorWidth = ONE / vmax (vabs (color), SampleType (3.0));
        let colorInternal = color / (ONE + vpow (xdBmthr * divColorWidth, 2));

        //CTF
        let ydB = viflt ( 
            threshold + xdBmthr * divRatio1, 
            viflt (
                softKnee,
                threshold + xdBmthr * divRatio0, 
                xdBmthr,
                softnessDiv2
            ),
            xdBmthr, 
            -softnessDiv2
        ) + colorInternal;

        //convert to linear gain
        return vmin (vdBtoGain (ydB) / x, MAX_EFFECT_GAIN);
    }

    /** Classical compressor transfer function (CTF) that can become 2 compression and 2 expansion transfer functions 
    
        Parameters:
        - ratio0: ratio above threshold (> 1 is downward compression, < 1 is upward expansion)
        - ratio1: ratio below threshold (> 1 is upward compression, < 1 is downward expansion)

        Notes:
        - See https://www.dropbox.com/s/cjq4t08u6pqkaas/ADC17FiftyShadesDistortion.zip?dl=0&file_subpath=%2FCode%2FDynamicsCompressor.cpp
    */
    SampleType vCTF (SampleType x, SampleType threshold, SampleType ratio0, SampleType ratio1)
    {
        let divRatio0m1 = ONE/ratio0 - ONE;
        let divRatio1m1 = ONE/ratio1 - ONE;

        let thrlin = vdBtoGain (threshold);

        let y = viflt (vpow (x * (ONE/thrlin), divRatio1m1), vpow (x * (ONE/thrlin), divRatio0m1), x, thrlin);

        return vmin (y, MAX_EFFECT_GAIN);
    }

    /** Bucket Brigade Device static nonlinear mapping
    
        Notes:
        - Use for low order, monotonically decreasing harmonics
        - Needs makeup gain at high settings, NOT always BIBO stable
        - Harmonics boosted compared to the original version according to the linear gain b
        - See: http://dafx10.iem.at/proceedings/papers/RaffelSmith_DAFx10_P42.pdf  
    */
    SampleType vBBD (SampleType x, SampleType b)
    {
        let c1 = b * SampleType (1.0/8.0);
        let c2 = b* SampleType (1.0/16.0);

        return x - c1 * vpow (x, 2) - c2 * vpow (x, 3); 
    }

    /** Omega (rad/s) modulation simulating anhysteretic nonlinear inductance/capacitance
    
        Parameters:
        - x: sidechain signal
        - N: nonlinearity

        Notes:
        - The reciprocal of a algebraic sigmoid of class C1
        - See: https://en.wikipedia.org/wiki/Differentiable_function#Differentiability_classes
        - The linear cutoff is 1. Add a bias if a different linear cutoff is desired
        (i.e. vLan (x, N) + bias)
    */
    SampleType vLan (SampleType x, SampleType N)
    {
        return vpow (N * vabs (x) + ONE, 2);
    }

    SampleType vStereoLink (SampleType x, float percent)
    {
        let b = vMixToGains (percent * 0.5f);
        let x1 = SampleType (x[1] , x[0]);

        return b.at(0) * x + b.at(1) * x1;
    }

    /** An algebraic sigmoid function of class C2

        f(x) = x / sqrt (x^2 + 1) 

        Notes:
        - A cheap 'tanh' approximation
        - See: https://en.wikipedia.org/wiki/Differentiable_function#Differentiability_classes
    */
    SampleType vSigmoidC2 (SampleType x)
    {
        return x / sqrt (x * x + ONE);
    }

    /** Convert cutoff (Hz) to the cutoff gain of a TPT Onepole filter 
    
        Notes:
        - Optimized for 'update'
        - Prewarped
    */
    SampleType vCutoffToG_Onepole (float x, float64 fs)
    {
        let Tpi = SampleType (pi / fs);
        
        let gOnepole = tanh (SampleType (x) * Tpi);

        return gOnepole / (ONE + gOnepole);
    }

    /** Convert Omega (rad/s) to the cutoff gain of a TPT Onepole filter 
    
        Notes:
        - Optimized for 'updatePerSample'
        - NOT prewarped
        - Use with 2x oversampling if using for frequency effects
    */
    SampleType vOmegaToG_Onepole (SampleType x, float64 fs)
    {
        let Tdiv2 = SampleType (1.0 / (2.0 * fs));

        let gOnepole = tan (x * Tdiv2);

        return gOnepole / (ONE + gOnepole);
    }

    /** Convert gain to decibels and limit to >= -100.0 dB */
    SampleType vGainTodB (SampleType x)
    {
        let b = vmax (NOISE_FLOOR, x);

        return SampleType (20.0) * log10 (b);
    }

    /** Convert decibels to gain and limit inputs to >= -100.0 dB */
    SampleType vdBtoGain (SampleType x)
    {
        let dB = vmax (NOISE_FLOOR_DB, x);

        return vpow (SampleType (10.0), dB * SampleType (1.0 / 20.0));
    }

    /** Return 1 if x is positive, -1 if negative otherwise */
    SampleType vSgn (SampleType x)
    {
        return SampleType (x[0] > 0 ? 1 : -1, x[1] > 0 ? 1 : -1);
    }

    /** Convert a mix and a pan to a SampleType[2] gain array
    
        Use case: mix and pan 2 SampleType streams simultaneously
    */
    SampleType[2] vMixPanToGains (float m, float p)
    {
        let bPan = vPanToGains (p);
        let bMix = vMixToGains (m);

        return SampleType[2] (bMix.at(0) * bPan.at(0), bMix.at(1) * bPan.at(1));
    }

    /** Convert a mix value in range [0, 100] to a SampleType[2] gain array
    
        Use case: mix 2 SampleType streams
    */
    SampleType[2] vMixToGains (float x)
    {
        let b1 = SampleType (x) * SampleType (1.0/100.0);

        return SampleType[2] (ONE - b1, b1);
    }
    
    /** Convert a pan value in range [-1, 1] to a SampleType[2] gain array
    
        Use case: pan 2 SampleType streams simultaneously
    */
    SampleType[2] vPanToGains (float x)
    {
        let b1 = vPanToGain(x);

        return SampleType[2] (TWO - b1, b1);
    }

    /** Convert a linear pan value in range [-1, 1] to a SampleType gain 

        Use case: pan 1 SampleType stream
    */
    SampleType vPanToGain (float x)
    {
        let bR = float64 (x) + 1.0;

        return SampleType (2.0 - bR, bR);
    }

    SampleType.elementType<4> vSampleTypesToSampleType2(SampleType x0, SampleType x1)
    {
        return SampleType.elementType<4> (x0[0], x0[1], x1[0], x1[1]);
    }

/*==============================================================================
Vectorized Intrinsic Functions                                          01/18/22
==============================================================================*/

    SampleType vabs (SampleType x)
    {
        return SampleType (abs (x[0]), abs (x[1]));
    }

    SampleType vmax (SampleType x0, SampleType x1)
    {
        return SampleType (max (x0[0], x1[0]), max (x0[1], x1[1]));
    }

    SampleType vmin (SampleType x0, SampleType x1)
    {
        return SampleType (min (x0[0], x1[0]), min (x0[1], x1[1]));
    }

    /** Vector reduce max */
    SampleType.elementType vmaxr (SampleType x)
    {
        return max (x[0], x[1]);
    }

    /** Vector reduce min */
    SampleType.elementType vminr (SampleType x)
    {
        return min (x[0], x[1]);
    }

    /** 'pow' for int and SampleType exponents 
    
        T:
        - SampleType: vectorized version of 'pow'
        - int: repeated multiplicaton
    */
    SampleType vpow<T> (SampleType base, T exponent)
    {
        let T_isSampleType = T.isVector;

        static_assert ((T_isSampleType || T.isInt), "vpow [[Vectorized Intrinsic Functions]]");
        
        if const (T_isSampleType)
            return SampleType (pow (base[0], exponent[0]), pow (base[1], exponent[1]));
        else if const (T.isInt)
        {
            SampleType y = base;

            for (int i = 1; i < exponent; ++i)
                y *= base;

            return y;
        }
        return ZERO;
    }

    /** a < b ? trueStatement : falseStatement */
    SampleType viflt (SampleType trueStatement, SampleType falseStatement, SampleType a, SampleType b)
    {
        return SampleType (a[0] < b[0] ? trueStatement [0] : falseStatement [0], a[1] < b[1] ? trueStatement [1] : falseStatement [1]);
    }

/*==============================================================================
Constants                                                               01/26/22
==============================================================================*/
    
    //const float
    let FLOAT_DC_BLOCKER_CUTOFF_HZ = 1.f;
    let FLOAT_DIV_SQRT_TWO = 1.f / sqrt (2.f);

    //soul::filters
    using SampleType = float64<2>;
    using SampleType2 = SampleType.elementType<SampleType.size * 2>;
    let updateInterval = 256;
    namespace filt = soul::filters (SampleType, SampleType.elementType, updateInterval);
    
    //const SampleType
    let ZERO = SampleType (0.0);
    let HALF = SampleType (0.5);
    let ONE = SampleType (1.0);
    let TWO = SampleType (2.0);
    
    let MAX_EFFECT_GAIN = SampleType (1.9);

    let NOISE_FLOOR = SampleType (0.00001);
    let NOISE_FLOOR_DB = SampleType (-100.0);

    let CHANNEL_ZERO_MASK = SampleType (1.0, 0.0);
    let CHANNEL_ONE_MASK = SampleType (0.0, 1.0);
    
    let ADAA_TOL = SampleType (0.0000001);

    //const int
    let INT_MAX_BUFFER_SIZE = 22050; //for arrays of SampleType
    let INT_MAX_BUFFER_SIZE_MS = 225; //INT_MAX_BUFFER_SIZE in ms @ 96kHz floored to nearest multiple of 25

} //namespace VA


/** Very unstable and random snippets */
namespace VA::Experimental
{
    /** vSigmoidC2 with a gain of 1 at the origin and drive (linear gain) of b
    
        Notes:
        - Use for state saturation with odd order harmonics
        - Requires makeup gain for most values of b
    */
    // SampleType vSigmoidC2S (SampleType x, SampleType b) 
    // {
    //     return vSigmoidC2 (b * x) * (ONE / b); 
    // }

    /** Decode mid/side to stereo */
    // SampleType vDecodeMidSide (SampleType x)
    // {
    //     return SampleType (0.5 * x.sum , 0.5 * (x[0] - x[1]));
    // }

    /** Encode stereo to mid/side */
    // SampleType vEncodeMidSide (SampleType x)
    // {
    //     return SampleType (x.sum(), x[0] - x[1]);
    // }

    /** soul::tpt::svf modified for cutoff/resonance modulation via input streams
    
        2x oversampling recommended
    */  
    namespace SvfCR
    {
        struct Coeffs
        {
            SampleType a0;
            SampleType a;
            SampleType p;
        }

        struct State
        {
            SampleType[2] z;
        }

        SampleType[3] process (State& s, SampleType x, const Coeffs& c)
        {
            let hpf = c.a0 * (x - c.p * s.z[0] - s.z[1]);
            let bpf = c.a * hpf + s.z[0];
            let lpf = c.a * bpf + s.z[1];

            s.z[0] = c.a * hpf + bpf;
            s.z[1] = c.a * bpf + lpf;

            return SampleType[3] (lpf, hpf, bpf);
        }

        processor Processor()
        {
            input stream SampleType in;
            input stream SampleType Omega; //angular cutoff; must be > 0
            input stream SampleType R; //resonance; must be > 0
            output stream SampleType lowpassOut, highpassOut, bandpassOut;

            void run()
            {
                State s;
                Coeffs c;

                let Tdiv2 = SampleType (processor.period * 0.5); 

                loop
                {
                    c.a = Omega * Tdiv2; //g
                    c.a0 = ONE / (ONE + TWO * R * c.a + c.a * c.a); //d
                    c.p = TWO * R + c.a; //g1

                    let y = s.process(in, c);

                    lowpassOut  << y[0];
                    highpassOut << y[1];
                    bandpassOut << y[2];
                    
                    advance();
                }
            }
        }
    }
} //namespace VA::Experimental
