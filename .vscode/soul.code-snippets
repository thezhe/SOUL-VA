{	
	"VA::graph": {
		"scope": "SOUL",
		"prefix": ["VA::graph", "graph"],
		"body": [
			"/** ${2:Description} */",
			"namespace ${1:Name}",
			"{",
			"    graph Processor()",
			"    {",
			"        input stream SampleType in;",
			"        output stream SampleType out;",
			"",
			"        input",
			"        {",
			"            ${3:Endpoint declarations}",
			"        }",
			"",
			"        let",
			"        {",
			"            ${4:Processor instance declarations}",
			"        }",
			"",
			"        connection",
			"        {",
			"            ${5:Connection declarations}",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "Create a 'Processor' in the 'VA' namespace using a 'graph'."
	},

	"VA::HighLevel::graph": {
		"scope": "SOUL",
		"prefix": ["VA::HighLevel::graph", "graphHighLevel"],
		"body": [
			"/** ${2:Description}",
			"",
			"    Use case: ${3:Use Case}",
			"*/",
			"namespace ${1:Name}",
			"{            ",
			"    graph Processor (${4:Initial Params}",
			"                    float iMakeup_dB = 0,",
			"                    float iMixPercent = 100)",
			"    {",
			"        input stream SampleType in ${7:Extra Input Streams};",
			"        output stream SampleType out ${8:Extra Output Streams};",
			"",
			"        input event",
			"        {",
			"            ${6:Shared Input Events}",
			"",
			"            smoothedVolume.volumeIn makeupIn [[ name: \"Makeup\", min: -12, max: 12, init: iMakeup_dB, step: 0.1f, unit: \"dB\", group: \"Utility\" ]];",
			"            smoothedMixPan.mixIn [[ name: \"Mix\", min: 0, max: 100, init: iMixPercent, unit: \"%\", step: 1, group: \"Utility\" ]];",
			"        }",
			"",
			"        let",
			"        {",
			"            internalDS0 = Internal::Processor (${5:Pass Initial Params});",
			"            internalDS2 = Internal::Processor (${5:Pass Initial Params}) / 2;",
			"            internalDS4 = Internal::Processor (${5:Pass Initial Params}) / 4;",
			"            mux3To1Fs = Mux3To1Fs::Processor;",
			"",
			"            smoothedVolume = SmoothedVolume::Processor (iMakeup_dB);",
			"            smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, 0);",
			"        }",
			"",
			"        connection",
			"        {",
			"            //shared input events",
			"            ${9:Connect DS Input Events}",
			"",
			"            //dynamically downsample to 44.1/48 kHz",
			"            [sinc] in -> internalDS0.in, internalDS2.in, internalDS4.in;",
			"",
			"            [sinc] internalDS0.out -> mux3To1Fs.in;",
			"            [sinc] internalDS2.out -> mux3To1Fs.in1;",
			"            [sinc] internalDS4.out -> mux3To1Fs.in2;",
			"",
			"            //utility",
			"            in -> smoothedMixPan.dryIn;",
			"            mux3To1Fs.out -> smoothedVolume.in;",
			"            smoothedVolume.out -> smoothedMixPan.wetIn;",
			"            smoothedMixPan.out -> out;",
			"        }",
			"    }",
			"    ",
			"    namespace Internal",
			"    {",
			"        graph Processor (${4:Initial Params})",
			"        {",
			"            input stream SampleType in ${7:Extra Input Streams};",
			"            output stream SampleType out ${8:Extra Output Streams};",
			"",
			"            input",
			"            {",
			"                ${10:Input Events}",
			"            }",
			"",
			"            let",
			"            {",
			"                dcBlocker = DC_Blocker::Processor;",
			"",
			"                ${11:Processors}",
			"            }",
			"",
			"            connection",
			"            {",
			"                in -> dcBlocker -> ${12:Processor connections}",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Create a 'Processor' in the 'VA::HighLevel' namespace using a 'graph'"
	},

	"VA::processor": {
		"scope": "SOUL",
		"prefix": ["VA::processor", "processor"],
		"body": [
			"/** ${2:Description} */",
			"namespace ${1:Name}",
			"{   ",
			"    struct Coeffs",
			"    {",
			"        ${3:'SampleType' coefficents}",
			"    }",
			"",
			"    void updatePerSample (Coeffs& c, ${4:Include 'event' or 'stream' parameters as 'float' or 'SampleType' arguments})",
			"    {",
			"        ${5:Map 'event' or 'stream' parameters to 'Coeffs' members}",
			"    }",
			"",
			"    void update (Coeffs& c, ${6:Include 'event' parameters as 'float' arguments})",
			"    {",
			"        ${7:Map 'event' parameters to 'Coeffs' members}",
			"    }",
			"    ",
			"    struct State",
			"    {",
			"        ${8:'SampleType' state variables}",
			"    }",
			"",
			"    SampleType process (State& s, SampleType x, const Coeffs& c)",
			"    {",
			"        ${9:Process one frame}",
			"    }",
			"",
			"    processor Processor (${10:Initialize 'event' parameters})",
			"    {",
			"        input stream SampleType in;",
			"        output stream SampleType out;",
			"",
			"        ${11:Define 'stream' parameters (example below)}",
			"",
			"        //input stream SampleType paramIn;",
			"",
			"        ${12:Define 'event' parameters (example below)}",
			"",
			"        /*input event float paramIn [[ name: \"Param\", min: 0, max: 1, init: initialParam, unit: \"units\", step: 1 ]];",
			"",
			"        event paramIn (float v) { param = v; recalc = true; }",
			"",
			"        float param = initialParam;*/",
			"",
			"        bool recalc = true;",
			"",
			"        void run()",
			"        {   ",
			"            State s;",
			"            Coeffs c;",
			"",
			"            ${13:Define constants that depend on processor.period or processor.frequency}",
			"",
			"            let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);",
			"",
			"            loop",
			"            {",
			"                if (recalc)",
			"                {",
			"                    recalc = false;",
			"",
			"                    c.update (${14:Pass 'event' parameters as arguments});",
			"                }",
			"",
			"                loop (updateIntervalSamples)",
			"                {",
			"                    c.updatePerSample (${15:Pass 'event' or 'stream' parameters as arguments});",
			"",
			"                    out << s.process (in, c);",
			"",
			"                    advance();",
			"                }",
			"            }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "Create a 'Processor' in the 'VA' namespace using a 'processor'."
	},

	"VA::processorADAA": {
		"scope": "SOUL",
		"prefix": ["VA::processorADAA", "processorADAA"],
		"body": [
			"/** ${2:Description of STATELESS function 'f'}",
			"",
			"    Notes:",
			"    - dynamic ADAA specifically optimized for ${3:Use Case}",
			"    - If sampling rate is 44.1kHz, use 2x oversampling",
			"    - Parameters are not suitable for modulation",
			"*/",
			"namespace ${1:Name}",
			"{   ",
			"    struct Coeffs",
			"    {",
			"        ${4:'SampleType' coefficients for 'f', 'F1', and 'F2'}",
			"        int adaa; //ADAA order",
			"    }",
			"",
			"    void update (Coeffs& c, ${5:Include 'event' parameters as 'float' arguments})",
			"    {",
			"        ${6:Map 'event' parameters to 'Coeffs' members}",
			"        c.adaa = ${7:ADAA rule}",
			"    }    ",
			"",
			"    SampleType f (SampleType x, const Coeffs& c)",
			"    {",
			"        ${8:Process one frame}",
			"    }",
			"",
			"    SampleType F1 (SampleType x, const Coeffs& c)",
			"    {",
			"        ${9:Process one frame of the first antiderivative of 'f'}",
			"    }",
			"",
			"    SampleType F2 (SampleType x, const Coeffs& c)",
			"    {",
			"        ${10:Process one frame of the second antiderivative of 'f'}",
			"    }",
			"",
			"    struct State",
			"    {",
			"        SampleType x_2;",
			"        SampleType x_1;",
			"        SampleType F2_1;",
			"        SampleType F1_1;",
			"    }",
			"",
			"    void reset (State& s)",
			"    {",
			"        s.x_2 = ZERO;",
			"        s.x_1 = ZERO;",
			"        s.F2_1 = ZERO;",
			"        s.F1_1 = ZERO;",
			"    }",
			"",
			"    SampleType processADAA2 (State& s, SampleType x, const Coeffs& c)",
			"    {",
			"        //Find F1_0",
			"        ",
			"        let x_0mx_1 = x - s.x_1;",
			"        let F2_0 = F2 (x, c);",
			"",
			"        let F1_0 = viflt (F1 (HALF * (x + s.x_1), c), ",
			"            (F2_0 - s.F2_1) / x_0mx_1,",
			"            vabs (x_0mx_1), DIV_TOL);",
			"",
			"        //Find f_0",
			"        let x_0mx_2 = x - s.x_2;",
			"",
			"        let xBar = HALF * (x + s.x_2);",
			"        let delta = xBar - s.x_1;",
			"",
			"        let f_0 = viflt (",
			"            viflt (",
			"                f (HALF * (xBar + s.x_1), c),",
			"                (TWO / delta) * (F1 (xBar, c) + (s.F2_1 - F2 (xBar, c)) / delta),",
			"                vabs (delta), DIV_TOL",
			"            ),",
			"            (TWO / (x_0mx_2)) * (F1_0 - s.F1_1),",
			"            vabs (x_0mx_2), DIV_TOL",
			"        );",
			"",
			"        //update s",
			"        s.x_2 = s.x_1;",
			"        s.x_1 = x;",
			"        s.F2_1 = F2_0;",
			"        s.F1_1 = F1_0;",
			"",
			"        return f_0;",
			"    }",
			"",
			"    SampleType processADAA1 (State& s, SampleType x, const Coeffs& c)",
			"    {",
			"        //Find f_0",
			"        let x_0mx_1 = x - s.x_1;",
			"        let F1_0 = F1 (x, c);",
			"",
			"        let f_0 = viflt (f (HALF * (x + s.x_1), c), ",
			"            (F1_0 - s.F1_1) / x_0mx_1,",
			"            vabs (x_0mx_1), DIV_TOL);",
			"",
			"        //update s",
			"        s.x_1 = x;",
			"        s.F1_1 = F1_0;",
			"",
			"        return f_0;",
			"    }",
			"",
			"    SampleType process (State& s, SampleType x, const Coeffs& c)",
			"    {",
			"        if (c.adaa == 0)",
			"           return f (x, c);",
			"        else if (c.adaa == 1)",
			"           return s.processADAA1 (x, c);",
			"        else",
			"           return s.processADAA2 (x, c);",
			"    }",
			"",
			"    processor Processor(${9:Initialize 'event' parameters})",
			"    {",
			"        input stream SampleType in;",
			"        output stream SampleType out;",
			"",
			"        ${12:Define 'event' parameters (example below)}",
			"",
			"        /*input event float paramIn [[ name: \"Param\", min: 0, max: 1, init: initialParam, unit: \"units\" , step: 1, group: \"unsmoothed\" ]];",
			"",
			"        event paramIn (float v) { param = v; recalc = true; }",
			"",
			"        float param = initialParam;*/",
			"",
			"        bool recalc = true;",
			"",
			"        void run()",
			"        {",
			"            State s;",
			"            Coeffs c;",
			"",
			"            ${13:Define constants that depend on processor.period or processor.frequency}",
			"",
			"            let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);",
			"",
			"            loop",
			"            {",
			"                if (recalc)",
			"                {",
			"                    recalc = false;",
			"",
			"                    c.update (${14:Pass 'event' parameters as arguments});",
			"                    s.reset();",
			"                }",
			"",
			"                loop (updateIntervalSamples)",
			"                {",
			"                    out << s.process (in, c);",
			"",
			"                    advance();",
			"                }",
			"            }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "Processor implementing STATELESS function 'f' and parameter-dependent ADAA order; do not change the ADAA boilerplate ('State' and all 'process' functions)"
	},

	"VA::EventParam": {
		"scope": "SOUL",
		"prefix": ["VA::EventParam", "EventParam"],
		"body": [
			"event float ${1:Endpoint Name}In [[ name: \"${2:Name}\", unit: \"${3:Unit}\", min: ${4:Min}, max: ${5:Max}, step: ${6:Step}, init: ${7:Init}, ${8|boolean,text:|}, group: ${9:Group} ]];"
		],
		"description": "An endpoint of type 'input event float'; this is updated internally every updateInterval."
	},

	"VA::HighLevel::ConnectDS": {
		"scope": "SOUL",
		"prefix": ["VA::HighLevel::ConnectDS", "ConnectDS"],
		"body": [
			"${1:Endpoint Name}In -> internalDS0.${1:Endpoint Name}In, internalDS2.${1:Endpoint Name}In, internalDS4.${1:Endpoint Name}In;"
		],
		"description": "Connect an event endpoint to the internalDS* in VA::HighLevel Processors."
	}
}