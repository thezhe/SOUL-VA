/** VSCode snippets (https://code.visualstudio.com/docs/editor/userdefinedsnippets) */
{	
	"VA::graph": {
		"prefix": "VA::graph",
		"body": [
			"/** ${2:Description} */",
			"namespace ${1:Name}",
			"{",
            "    let oversampling = 1;",
            "",
			"    graph Processor()",
			"    {",
			"        input stream SampleType in;",
			"        output stream SampleType out;",
			"",
			"        input",
			"        {",
			"            ${3:Endpoint declarations}",
			"        }",
			"",
			"        let",
			"        {",
			"            ${4:Processor instance declarations}",
			"        }",
			"",
			"        connection",
			"        {",
			"            ${5:Connection declarations}",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "Create a 'Processor' in the 'VA' namespace using a 'graph'."
	},

    "VA::graphHighLevel": {
        "prefix": "VA::graphHighLevel",
        "body": [
            "/** ${2:Description}",
            "",
            "    Use case: ${3:Use Case}",
            "*/",
            "namespace ${1:Name}",
            "{",
            "    let oversampling = 1;",
            "",
            "    graph Processor(${4:Initial Params},",
            "                    float iMixPercent = 100,",
            "                    float iPan = 0,",
            "                    float iMakeupVolume_dB = 0)",
            "    {",
            "        input stream SampleType in;",
            "        output stream SampleType out;",
            "",
            "        input",
            "        {",
            "            ${5:Non-Boilerplate Input Events}",
            "",
            "            smoothedMixPan.mixIn;",
            "            smoothedMixPan.panIn;",
            "            smoothedVolume.volumeIn makeupVolumeIn [[ name: \"Makeup Volume\", min: -12, max: 12, init: iMakeupVolume_dB, step: 0.1f, unit: \"dB\" ]];",
            "        }",
            "",
            "        let",
            "        {",
            "            //non-boilerplate Processors",
            "            ${6:Non-Boilerplate Processors}",
            "",
            "            //boilerplate Processors",
            "            dcBlockerIn = filt::dc_blocker::Processor (FLOAT_DC_BLOCKER_CUTOFF_HZ);",
            "            dcBlockerOut = filt::dc_blocker::Processor (FLOAT_DC_BLOCKER_CUTOFF_HZ);",
            "",
            "            smoothedMixPan = SmoothedMixPan::Processor (iMixPercent, iPan);",
            "            smoothedVolume = SmoothedVolume::Processor (iMakeupVolume_dB);",
            "        }",
            "",
            "        connection",
            "        {",
            "            in -> dcBlockerIn -> smoothedMixPan.in0, ${7:Non-Boilerplate Input(s)};",
            "            ",
            "",
            "            ${8:Non-Boilerplate Output(s)} -> smoothedMixPan.in1;",
            "            smoothedMixPan.out -> smoothedVolume.in;",
            "            smoothedVolume.out -> dcBlockerOut -> out;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Create a 'Processor' in the 'VA::HighLevel' using a 'graph'."
    },

    "VA::processor": {
		"prefix": "VA::processor",
		"body": [
			"/** ${2:Description} */",
			"namespace ${1:Name}",
			"{   ",
			"    struct Coeffs",
			"    {",
			"        ${3:'SampleType' coefficents}",
			"    }",
			"",
            "    void updatePerSample (Coeffs& c, ${4:Include 'event' or 'stream' parameters as 'float' or 'SampleType' arguments})",
            "    {",
            "        ${5:Map 'event' or 'stream' parameters to 'Coeffs' members}",
            "    }",
            "",
			"    void update (Coeffs& c, ${6:Include 'event' parameters as 'float' arguments})",
			"    {",
			"        ${7:Map 'event' parameters to 'Coeffs' members}",
			"    }",
			"    ",
			"    struct State",
			"    {",
			"        ${8:'SampleType' state variables}",
			"    }",
			"",
			"    SampleType process (State& s, SampleType x, const Coeffs& c)",
			"    {",
			"        ${9:Process one frame}",
			"    }",
			"",
			"    processor Processor (${10:Initialize 'event' parameters})",
			"    {",
			"        input stream SampleType in;",
			"        output stream SampleType out;",
			"",
			"        ${11:Define 'stream' parameters (example below)}",
			"",
			"        //input stream SampleType paramIn;",
			"",
			"        ${12:Define 'event' parameters (example below)}",
			"",
			"        /*input event float paramIn [[ name: \"Param\", min: 0, max: 1, init: initialParam, unit: \"units\", step: 1 ]];",
			"",
			"        event paramIn (float v) { param = v; recalc = true; }",
			"",
			"        float param = initialParam;*/",
			"",
			"        bool recalc = true;",
			"",
			"        void run()",
			"        {   ",
			"            State s;",
			"            Coeffs c;",
			"",
			"            ${13:Define constants that depend on processor.period or processor.frequency}",
            "",
            "            let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);",
            "",
			"            loop",
			"            {",
			"                if (recalc)",
			"                {",
			"                    recalc = false;",
			"",
			"                    c.update (${14:Pass 'event' parameters as arguments});",
			"                }",
			"",
			"                loop (updateIntervalSamples)",
			"                {",
			"                    c.updatePerSample (${15:Pass 'event' or 'stream' parameters as arguments});",
			"",
			"                    out << s.process (in, c);",
			"",
			"                    advance();",
			"                }",
			"            }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "Create a 'Processor' in the 'VA' namespace using a 'processor'."
	},

	"VA::processorADAA": {
        "prefix": "VA::processorADAA",
        "body": [
            "/** ${2:Description of STATELESS function 'f'}",
            "",
            "    Notes:",
            "    - dynamic ADAA specifically optimized for ${3:Use Case}",
            "    - If sampling rate is 44.1kHz, use 2x oversampling",
            "    - Parameters are not suitable for modulation",
            "*/",
            "namespace ${1:Name}",
            "{   ",
            "    struct Coeffs",
            "    {",
            "        ${4:'SampleType' coefficients for 'f', 'F1', and 'F2'}",
            "        int adaa; //ADAA order",
            "    }",
            "",
            "    void update (Coeffs& c, ${5:Include 'event' parameters as 'float' arguments})",
            "    {",
            "        ${6:Map 'event' parameters to 'Coeffs' members}",
            "        c.adaa = ${7:ADAA rule}",
            "    }    ",
			"",
            "    SampleType f (SampleType x, const Coeffs& c)",
            "    {",
            "        ${8:Process one frame}",
            "    }",
            "",
            "    SampleType F1 (SampleType x, const Coeffs& c)",
            "    {",
            "        ${9:Process one frame of the first antiderivative of 'f'}",
            "    }",
            "",
            "    SampleType F2 (SampleType x, const Coeffs& c)",
            "    {",
            "        ${10:Process one frame of the second antiderivative of 'f'}",
            "    }",
			"",
            "    struct State",
            "    {",
            "        SampleType x_2;",
            "        SampleType x_1;",
            "        SampleType F2_1;",
            "        SampleType F1_1;",
            "    }",
            "",
            "    void reset (State& s)",
            "    {",
            "        s.x_2 = ZERO;",
            "        s.x_1 = ZERO;",
            "        s.F2_1 = ZERO;",
            "        s.F1_1 = ZERO;",
            "    }",
            "",
            "    SampleType processADAA2 (State& s, SampleType x, const Coeffs& c)",
            "    {",
            "        //Find F1_0",
            "        ",
            "        let x_0mx_1 = x - s.x_1;",
            "        let F2_0 = F2 (x, c);",
            "",
            "        let F1_0 = viflt (F1 (HALF * (x + s.x_1), c), ",
            "            (F2_0 - s.F2_1) / x_0mx_1,",
            "            vabs (x_0mx_1), ADAA_TOL);",
            "",
            "        //Find f_0",
            "        let x_0mx_2 = x - s.x_2;",
            "",
            "        let xBar = HALF * (x + s.x_2);",
            "        let delta = xBar - s.x_1;",
            "",
            "        let f_0 = viflt (",
            "            viflt (",
            "                f (HALF * (xBar + s.x_1), c),",
            "                (TWO / delta) * (F1 (xBar, c) + (s.F2_1 - F2 (xBar, c)) / delta),",
            "                vabs (delta), ADAA_TOL",
            "            ),",
            "            (TWO / (x_0mx_2)) * (F1_0 - s.F1_1),",
            "            vabs (x_0mx_2), ADAA_TOL",
            "        );",
            "",
            "        //update s",
            "        s.x_2 = s.x_1;",
            "        s.x_1 = x;",
            "        s.F2_1 = F2_0;",
            "        s.F1_1 = F1_0;",
            "",
            "        return f_0;",
            "    }",
            "",
            "    SampleType processADAA1 (State& s, SampleType x, const Coeffs& c)",
            "    {",
            "        //Find f_0",
            "        let x_0mx_1 = x - s.x_1;",
            "        let F1_0 = F1 (x, c);",
            "",
			"        let f_0 = viflt (f (HALF * (x + s.x_1), c), ",
		    "            (F1_0 - s.F1_1) / x_0mx_1,",
		    "            vabs (x_0mx_1), ADAA_TOL);",
            "",
            "        //update s",
            "        s.x_1 = x;",
            "        s.F1_1 = F1_0;",
            "",
            "        return f_0;",
            "    }",
            "",
            "    SampleType process (State& s, SampleType x, const Coeffs& c)",
            "    {",
            "        if (c.adaa == 0)",
            "           return f (x, c);",
            "        else if (c.adaa == 1)",
            "           return s.processADAA1 (x, c);",
            "        else",
            "           return s.processADAA2 (x, c);",
            "    }",
            "",
            "    processor Processor(${9:Initialize 'event' parameters})",
            "    {",
            "        input stream SampleType in;",
            "        output stream SampleType out;",
            "",
            "        ${12:Define 'event' parameters (example below)}",
            "",
            "        /*input event float paramIn [[ name: \"Param\", min: 0, max: 1, init: initialParam, unit: \"units\" , step: 1, group: \"unsmoothed\" ]];",
            "",
            "        event paramIn (float v) { param = v; recalc = true; }",
            "",
            "        float param = initialParam;*/",
            "",
            "        bool recalc = true;",
            "",
            "        void run()",
            "        {",
            "            State s;",
            "            Coeffs c;",
            "",
            "            ${13:Define constants that depend on processor.period or processor.frequency}",
            "",
            "            let updateIntervalSamples = int ((processor.frequency / 44100.0) * updateInterval);",
            "",
            "            loop",
            "            {",
            "                if (recalc)",
            "                {",
            "                    recalc = false;",
            "",
            "                    c.update (${14:Pass 'event' parameters as arguments});",
            "                    s.reset();",
            "                }",
            "",
            "                loop (updateIntervalSamples)",
            "                {",
            "                    out << s.process (in, c);",
            "",
            "                    advance();",
            "                }",
            "            }",
            "        }",
            "    }",
            "}",
            ""
        ],
        "description": "Processor implementing STATELESS function 'f' and parameter-dependent ADAA order; do not change the ADAA boilerplate ('State' and all 'process' functions)"
    },

    "VA::Modes": {
        "prefix": "VA::Modes",
        "body": [
            "namespace Modes",
            "{",
            "    let None = 0;",
            "    ${1:additional Modes}",
            "    let NumModes = 1;",
            "}",
            "",
            "namespace M (int mode = ${2:default mode})",
            "{",
            "    static_assert ((mode < Modes::NumModes) && (mode > -1), \"${3:Processor namespace}: mode out of range.\");",
            "",
            "    ${4:mode-specific code (examples below)}",
            "",
            "    //let param = (mode == Modes::None ? 0 : 1)",
            "",
            "    /*void process (State& s, SampleType x, const Coeffs& c)",
            "    {",
            "        if const (mode == Modes::None)",
            "           return ZERO;",
            "    }*/",
            "}",
            ""
        ],
        "description": "Define modes and namespace with compile time mode-specific code (e.g., a mode-dependent 'process' function); use to avoid the boilerplate from creating an entirely new Processor"
    },

    "VA::EventParam": {
        "prefix": "VA::EventParam",
        "body": [
            "input event float ${1:Endpoint Name}In [[ name: \"${2:Name}\", min: ${3:Min}, max: ${4:Max}, init: ${5:Init}, step: ${6:Step}, unit: \"${7:Unit}\" ]];"
        ],
        "description": "An endpoint of type 'input event float'; this is updated internally every updateInterval."
    }
}